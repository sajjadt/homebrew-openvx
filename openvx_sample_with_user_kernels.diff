diff -Npur -x '.*' a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt	2016-06-17 10:02:34.000000000 -0700
+++ b/CMakeLists.txt	2016-08-07 22:58:39.000000000 -0700
@@ -50,6 +50,8 @@ if (WIN32)
     include( CMake_windows_tools )
 elseif (ANDROID)
     include( CMake_android_tools )
+elseif (APPLE)
+    include( CMake_apple_tools )
 else ()
     include( CMake_linux_tools )
 endif ()
@@ -76,13 +78,13 @@ option( EXPERIMENTAL_PLATFORM_SUPPORTS_1
 
 if (UNIX OR ANDROID)
     add_definitions( -D_XOPEN_SOURCE=700 -D_BSD_SOURCE=1 -D_GNU_SOURCE=1 )
-    if (NOT (CYGWIN OR ANDROID))
+    if (NOT (CYGWIN OR ANDROID OR APPLE))
         set( EXPERIMENTAL_USE_OPENMP ON )
-    endif (NOT (CYGWIN OR ANDROID))
+    endif (NOT (CYGWIN OR ANDROID OR APPLE))
     set( EXPERIMENTAL_USE_DOT ON )
 endif (UNIX OR ANDROID)
 
-add_definitions( -DOPENVX_BUILDING ) 
+add_definitions( -DOPENVX_BUILDING )
 if (OPENVX_USE_SMP)
     add_definitions( -DOPENVX_USE_SMP )
 endif (OPENVX_USE_SMP)
@@ -171,6 +173,5 @@ add_subdirectory( helper )
 add_subdirectory( kernels )
 add_subdirectory( libraries )
 add_subdirectory( sample )
-add_subdirectory( sample-c++ )
 add_subdirectory( tools )
 add_subdirectory( include )
diff -Npur -x '.*' a/cmake_utils/CMakeFuncs.txt b/cmake_utils/CMakeFuncs.txt
--- a/cmake_utils/CMakeFuncs.txt	2016-06-17 10:02:15.000000000 -0700
+++ b/cmake_utils/CMakeFuncs.txt	2016-08-07 20:32:23.000000000 -0700
@@ -86,7 +86,7 @@ endmacro( FILTER_SOURCES )
 function ( FIND_SOURCES )
     file( GLOB HEADER_FILES_TMP RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} *.h *.hpp )
     file( GLOB SOURCE_FILES_TMP RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} *.c *.cpp *.cc )
-	
+
 	if (${ARGC} EQUAL 0 )
         set( FILER_OUT_REGEXP "not used regexp" )
     else()
@@ -108,13 +108,17 @@ function ( FIND_NUM_PROCESSORS )
   if ( WIN32 )
     set(PROCESSOR_COUNT_T "$ENV{NUMBER_OF_PROCESSORS}")
   else ( WIN32 )
-	set(CPUINFO_FILE "/proc/cpuinfo")
-	if(EXISTS "${CPUINFO_FILE}")
-		file(STRINGS "${CPUINFO_FILE}" PROCS REGEX "^processor.: [0-9]+$")
-		list(LENGTH PROCS PROCESSOR_COUNT_T)
-	else(EXISTS "${CPUINFO_FILE}")
-		set(PROCESSOR_COUNT_T "1")
-	endif(EXISTS "${CPUINFO_FILE}")
+    if ( APPLE )
+      set(PROCESSOR_COUNT_T "4")
+    else ( APPLE )
+	    set(CPUINFO_FILE "/proc/cpuinfo")
+	    if(EXISTS "${CPUINFO_FILE}")
+		    file(STRINGS "${CPUINFO_FILE}" PROCS REGEX "^processor.: [0-9]+$")
+		    list(LENGTH PROCS PROCESSOR_COUNT_T)
+	    else(EXISTS "${CPUINFO_FILE}")
+		    set(PROCESSOR_COUNT_T "1")
+	    endif(EXISTS "${CPUINFO_FILE}")
+    endif ( APPLE )
   endif( WIN32 )
   set( PROCESSOR_COUNT ${PROCESSOR_COUNT_T} PARENT_SCOPE )
 endfunction ( FIND_NUM_PROCESSORS )
diff -Npur -x '.*' a/cmake_utils/CMake_apple_tools.cmake b/cmake_utils/CMake_apple_tools.cmake
--- a/cmake_utils/CMake_apple_tools.cmake	1969-12-31 16:00:00.000000000 -0800
+++ b/cmake_utils/CMake_apple_tools.cmake	2016-08-07 20:35:57.000000000 -0700
@@ -0,0 +1,85 @@
+#
+# Copyright (c) 2011-2014 The Khronos Group Inc.
+#
+# Permission is hereby granted, free of charge, to any person obtaining a
+# copy of this software and/or associated documentation files (the
+# "Materials"), to deal in the Materials without restriction, including
+# without limitation the rights to use, copy, modify, merge, publish,
+# distribute, sublicense, and/or sell copies of the Materials, and to
+# permit persons to whom the Materials are furnished to do so, subject to
+# the following conditions:
+#
+# The above copyright notice and this permission notice shall be included
+# in all copies or substantial portions of the Materials.
+#
+# THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+# MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
+#
+
+# Options common to all projects.
+message(STATUS "** ** ** Enable Languages ** ** **")
+
+enable_language( C )
+enable_language( CXX )
+
+if(BUILD_X64)
+  set(ARCH_BIT -m64 )
+else()
+  if (TARGET_CPU STREQUAL "Atom")
+    # architecture will be according to ATOM
+    set(ARCH_BIT -m32 )
+  else ()
+    # need to force a more modern architecture than the degault m32 (i386).
+    set(ARCH_BIT "-m32 -march=core2" )
+  endif (TARGET_CPU STREQUAL "Atom")
+endif()
+
+
+# Compiler switches that CANNOT be modified during makefile generation
+set (ADD_COMMON_C_FLAGS         "${ARCH_BIT} -fPIC" )
+
+set (ADD_C_FLAGS                "${ADD_COMMON_C_FLAGS} -std=gnu99" )
+set (ADD_C_FLAGS_DEBUG          "-O0 -ggdb3 -D _DEBUG" )
+set (ADD_C_FLAGS_RELEASE        "-O2 -ggdb2 -U _DEBUG")
+set (ADD_C_FLAGS_RELWITHDEBINFO "-O2 -ggdb3 -U _DEBUG")
+
+set (ADD_CXX_FLAGS              "${ADD_COMMON_C_FLAGS}" )
+
+
+set(CMAKE_BUILD_WITH_INSTALL_RPATH    TRUE )   # build rpath as if already installed
+set(CMAKE_INSTALL_RPATH               "$ORIGIN::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::" ) # the rpath to use - search through installation dir only
+set(CMAKE_INSTALL_RPATH_USE_LINK_PATH FALSE)   # do not use static link paths as rpath
+
+# C switches
+set( CMAKE_C_FLAGS                          "${CMAKE_C_FLAGS}                         ${ADD_C_FLAGS}")
+set( CMAKE_C_FLAGS_DEBUG                    "${CMAKE_C_FLAGS_DEBUG}                   ${ADD_C_FLAGS_DEBUG}")
+set( CMAKE_C_FLAGS_RELEASE                  "${CMAKE_C_FLAGS_RELEASE}                 ${ADD_C_FLAGS_RELEASE}")
+set( CMAKE_C_FLAGS_RELWITHDEBINFO           "${CMAKE_C_FLAGS_RELWITHDEBINFO}          ${ADD_C_FLAGS_RELWITHDEBINFO}")
+
+# C++ switches
+set( CMAKE_CXX_FLAGS                        "${CMAKE_CXX_FLAGS}                       ${ADD_CXX_FLAGS}")
+set( CMAKE_CXX_FLAGS_DEBUG                  "${CMAKE_CXX_FLAGS_DEBUG}                 ${ADD_C_FLAGS_DEBUG}")
+set( CMAKE_CXX_FLAGS_RELEASE                "${CMAKE_CXX_FLAGS_RELEASE}               ${ADD_C_FLAGS_RELEASE}")
+set( CMAKE_CXX_FLAGS_RELWITHDEBINFO         "${CMAKE_CXX_FLAGS_RELWITHDEBINFO}        ${ADD_C_FLAGS_RELWITHDEBINFO}")
+
+# Linker switches - EXE
+set( CMAKE_EXE_LINKER_FLAGS                 "${INIT_LINKER_FLAGS}")
+
+# Linker switches - DLL
+set( CMAKE_SHARED_LINKER_FLAGS              "${INIT_LINKER_FLAGS}                     ${ADD_CMAKE_EXE_LINKER_FLAGS}")
+
+message(STATUS "\n\n** ** ** COMPILER Definitions ** ** **")
+message(STATUS "CMAKE_C_COMPILER        = ${CMAKE_C_COMPILER}")
+message(STATUS "CMAKE_C_FLAGS           = ${CMAKE_C_FLAGS}")
+message(STATUS "")
+message(STATUS "CMAKE_CXX_COMPILER      = ${CMAKE_CXX_COMPILER}")
+message(STATUS "CMAKE_CXX_FLAGS         = ${CMAKE_CXX_FLAGS}")
+message(STATUS "")
+message(STATUS "CMAKE_EXE_LINKER_FLAGS  = ${CMAKE_EXE_LINKER_FLAGS}")
+message(STATUS "")
+message(STATUS "CMAKE_BUILD_TOOL        = ${CMAKE_BUILD_TOOL}")
diff -Npur -x '.*' a/debug/CMakeLists.txt b/debug/CMakeLists.txt
--- a/debug/CMakeLists.txt	2016-06-17 10:02:32.000000000 -0700
+++ b/debug/CMakeLists.txt	2016-08-07 20:38:29.000000000 -0700
@@ -31,7 +31,7 @@
 set( TARGET_NAME vx_debug )
 
 include_directories( BEFORE
-                     ${CMAKE_CURRENT_SOURCE_DIR} 
+                     ${CMAKE_CURRENT_SOURCE_DIR}
 					 ${CMAKE_SOURCE_DIR}/include )
 
 FIND_SOURCES()
@@ -39,9 +39,9 @@ FIND_SOURCES()
 # add a target named ${TARGET_NAME}
 add_library (${TARGET_NAME} ${SOURCE_FILES})
 
-install ( TARGETS ${TARGET_NAME} 
+install ( TARGETS ${TARGET_NAME}
           RUNTIME DESTINATION bin
-          ARCHIVE DESTINATION bin
-          LIBRARY DESTINATION bin )
-		  
+          ARCHIVE DESTINATION lib
+          LIBRARY DESTINATION lib )
+
 set_target_properties( ${TARGET_NAME} PROPERTIES FOLDER ${DEBUG_FOLDER} )
diff -Npur -x '.*' a/helper/CMakeLists.txt b/helper/CMakeLists.txt
--- a/helper/CMakeLists.txt	2016-06-17 10:02:30.000000000 -0700
+++ b/helper/CMakeLists.txt	2016-08-07 20:38:41.000000000 -0700
@@ -31,7 +31,7 @@
 set( TARGET_NAME openvx-helper )
 
 include_directories( BEFORE
-                     ${CMAKE_CURRENT_SOURCE_DIR} 
+                     ${CMAKE_CURRENT_SOURCE_DIR}
 					 ${CMAKE_SOURCE_DIR}/include )
 
 FIND_SOURCES()
@@ -39,9 +39,9 @@ FIND_SOURCES()
 # add a target named ${TARGET_NAME}
 add_library (${TARGET_NAME} ${SOURCE_FILES})
 
-install ( TARGETS ${TARGET_NAME} 
+install ( TARGETS ${TARGET_NAME}
           RUNTIME DESTINATION bin
-          ARCHIVE DESTINATION bin
-          LIBRARY DESTINATION bin )
-		  
+          ARCHIVE DESTINATION lib
+          LIBRARY DESTINATION lib )
+
 set_target_properties( ${TARGET_NAME} PROPERTIES FOLDER ${HELPER_FOLDER} )
diff -Npur -x '.*' a/include/VX/vx_kernels.h b/include/VX/vx_kernels.h
--- a/include/VX/vx_kernels.h	2016-06-17 10:02:32.000000000 -0700
+++ b/include/VX/vx_kernels.h	2016-08-08 16:06:56.000000000 -0700
@@ -1,4 +1,4 @@
-/* 
+/*
  * Copyright (c) 2012-2016 The Khronos Group Inc.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
@@ -299,6 +299,21 @@ enum vx_kernel_e {
     */
     VX_KERNEL_NON_LINEAR_FILTER = VX_KERNEL_BASE(VX_ID_KHRONOS, VX_LIBRARY_KHR_BASE) + 0x2C,
 
+    /*! \brief The Find SIFT Keypoint Kernel.
+  	* \see group_kernel_findingsift
+  	*/
+  	VX_KERNEL_FINDSIFTKEYPOINT = VX_KERNEL_BASE(VX_ID_KHRONOS, VX_LIBRARY_KHR_BASE) + 0x2A,
+
+  	/*! \brief The Verify SIFT Keypoint Kernel.
+  	* \see group_verify_keypoint
+  	*/
+  	VX_KERNEL_VERIFYKEYPOINT = VX_KERNEL_BASE(VX_ID_KHRONOS, VX_LIBRARY_KHR_BASE) + 0x2B,
+
+  	/*! \brief The Calc SIFT Gradient Kernel.
+  	* \see group_calc_sift_gradient
+  	*/
+  	VX_KERNEL_CALCSIFTGRADIENT = VX_KERNEL_BASE(VX_ID_KHRONOS, VX_LIBRARY_KHR_BASE) + 0x2C,
+
     /* insert new kernels here */
     VX_KERNEL_MAX_1_0, /*!< \internal Used for bounds checking in the conformance test. */
 };
diff -Npur -x '.*' a/include/VX/vx_nodes.h b/include/VX/vx_nodes.h
--- a/include/VX/vx_nodes.h	2016-06-17 10:02:32.000000000 -0700
+++ b/include/VX/vx_nodes.h	2016-08-08 15:55:58.000000000 -0700
@@ -1,4 +1,4 @@
-/* 
+/*
  * Copyright (c) 2012-2016 The Khronos Group Inc.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
@@ -46,7 +46,7 @@ extern "C" {
  * \see <tt>VX_KERNEL_COLOR_CONVERT</tt>
  * \ingroup group_vision_function_colorconvert
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt> 
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxColorConvertNode(vx_graph graph, vx_image input, vx_image output);
 
@@ -58,7 +58,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxColor
  * <tt>\see VX_KERNEL_CHANNEL_EXTRACT</tt>
  * \ingroup group_vision_function_channelextract
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt> 
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxChannelExtractNode(vx_graph graph,
                              vx_image input,
@@ -75,7 +75,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxChann
  * \see <tt>VX_KERNEL_CHANNEL_COMBINE</tt>
  * \ingroup group_vision_function_channelcombine
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt> 
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxChannelCombineNode(vx_graph graph,
                              vx_image plane0,
@@ -92,7 +92,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxChann
  * \see <tt>VX_KERNEL_PHASE</tt>
  * \ingroup group_vision_function_phase
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt> 
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxPhaseNode(vx_graph graph, vx_image grad_x, vx_image grad_y, vx_image orientation);
 
@@ -104,7 +104,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxPhase
  * \see <tt>VX_KERNEL_SOBEL_3x3</tt>
  * \ingroup group_vision_function_sobel3x3
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt> 
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxSobel3x3Node(vx_graph graph, vx_image input, vx_image output_x, vx_image output_y);
 
@@ -117,7 +117,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxSobel
  * \see <tt>VX_KERNEL_MAGNITUDE</tt>
  * \ingroup group_vision_function_magnitude
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt> 
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxMagnitudeNode(vx_graph graph, vx_image grad_x, vx_image grad_y, vx_image mag);
 
@@ -127,11 +127,11 @@ VX_API_ENTRY vx_node VX_API_CALL vxMagni
  * \param [out] dst The destination image of type <tt>\ref VX_DF_IMAGE_U8</tt>.
  * \param [in] type The interpolation type to use. \see vx_interpolation_type_e.
  * \ingroup group_vision_function_scale_image
- * \note The destination image must have a defined size and format. The border modes 
- *  <tt>\ref VX_NODE_BORDER</tt> value <tt>\ref VX_BORDER_UNDEFINED</tt>, 
+ * \note The destination image must have a defined size and format. The border modes
+ *  <tt>\ref VX_NODE_BORDER</tt> value <tt>\ref VX_BORDER_UNDEFINED</tt>,
  *  <tt>\ref VX_BORDER_REPLICATE</tt> and <tt>\ref VX_BORDER_CONSTANT</tt> are supported.
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt> 
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxScaleImageNode(vx_graph graph, vx_image src, vx_image dst, vx_enum type);
 
@@ -152,7 +152,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxTable
  * \param [out] distribution The output distribution.
  * \ingroup group_vision_function_histogram
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt> 
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxHistogramNode(vx_graph graph, vx_image input, vx_distribution distribution);
 
@@ -162,7 +162,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxHisto
  * \param [out] output The grayscale output image of type <tt>\ref VX_DF_IMAGE_U8</tt> with equalized brightness and contrast.
  * \ingroup group_vision_function_equalize_hist
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt> 
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxEqualizeHistNode(vx_graph graph, vx_image input, vx_image output);
 
@@ -172,7 +172,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxEqual
  * \param [in] in2 An input image in <tt>\ref VX_DF_IMAGE_U8</tt> or <tt>\ref VX_DF_IMAGE_S16</tt> format.
  * \param [out] out The output image in <tt>\ref VX_DF_IMAGE_U8</tt> or <tt>\ref VX_DF_IMAGE_S16</tt> format.
  * \ingroup group_vision_function_absdiff
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt> 
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxAbsDiffNode(vx_graph graph, vx_image in1, vx_image in2, vx_image out);
 
@@ -183,7 +183,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxAbsDi
  * \param [out] stddev The <tt>\ref VX_TYPE_FLOAT32</tt> standard deviation of the pixel values.
  * \ingroup group_vision_function_meanstddev
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt> 
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxMeanStdDevNode(vx_graph graph, vx_image input, vx_scalar mean, vx_scalar stddev);
 
@@ -191,12 +191,12 @@ VX_API_ENTRY vx_node VX_API_CALL vxMeanS
  * \param [in] graph The reference to the graph.
  * \param [in] input The input image. <tt>\ref VX_DF_IMAGE_U8</tt> is supported.
  * \param [in] thresh The thresholding object that defines the parameters of
- * the operation. The <tt>\ref VX_THRESHOLD_TRUE_VALUE</tt> and <tt>\ref VX_THRESHOLD_FALSE_VALUE</tt> are taken into account. 
- * \param [out] output The output Boolean image with values either <tt>\ref VX_THRESHOLD_TRUE_VALUE</tt> or 
+ * the operation. The <tt>\ref VX_THRESHOLD_TRUE_VALUE</tt> and <tt>\ref VX_THRESHOLD_FALSE_VALUE</tt> are taken into account.
+ * \param [out] output The output Boolean image with values either <tt>\ref VX_THRESHOLD_TRUE_VALUE</tt> or
  * <tt>\ref VX_THRESHOLD_FALSE_VALUE</tt> from the \e thresh parameter.
  * \ingroup group_vision_function_threshold
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt> 
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxThresholdNode(vx_graph graph, vx_image input, vx_threshold thresh, vx_image output);
 
@@ -206,7 +206,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxThres
  * \param [out] output The output image in <tt>\ref VX_DF_IMAGE_U32</tt> format.
  * \ingroup group_vision_function_integral_image
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt> 
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxIntegralImageNode(vx_graph graph, vx_image input, vx_image output);
 
@@ -216,7 +216,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxInteg
  * \param [out] output The output image in <tt>\ref VX_DF_IMAGE_U8</tt> format.
  * \ingroup group_vision_function_erode_image
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt> 
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxErode3x3Node(vx_graph graph, vx_image input, vx_image output);
 
@@ -226,7 +226,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxErode
  * \param [out] output The output image in <tt>\ref VX_DF_IMAGE_U8</tt> format.
  * \ingroup group_vision_function_dilate_image
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt> 
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxDilate3x3Node(vx_graph graph, vx_image input, vx_image output);
 
@@ -236,7 +236,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxDilat
  * \param [out] output The output image in <tt>\ref VX_DF_IMAGE_U8</tt> format.
  * \ingroup group_vision_function_median_image
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt> 
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxMedian3x3Node(vx_graph graph, vx_image input, vx_image output);
 
@@ -246,7 +246,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxMedia
  * \param [out] output The output image in <tt>\ref VX_DF_IMAGE_U8</tt> format.
  * \ingroup group_vision_function_box_image
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt> 
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxBox3x3Node(vx_graph graph, vx_image input, vx_image output);
 
@@ -256,7 +256,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxBox3x
  * \param [out] output The output image in <tt>\ref VX_DF_IMAGE_U8</tt> format.
  * \ingroup group_vision_function_gaussian_image
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt> 
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxGaussian3x3Node(vx_graph graph, vx_image input, vx_image output);
 
@@ -264,11 +264,11 @@ VX_API_ENTRY vx_node VX_API_CALL vxGauss
  * \param [in] graph The reference to the graph.
  * \param [in] function The non-linear filter function. See <tt>\ref vx_non_linear_filter_e</tt>.
  * \param [in] input The input image in <tt>\ref VX_DF_IMAGE_U8</tt> format.
- * \param [in] mask The mask to be applied to the Non-linear function. <tt>\ref VX_MATRIX_ORIGIN</tt> attribute is used 
- *  to place the mask appropriately when computing the resulting image. See <tt>\ref vxCreateMatrixFromPattern</tt>.  
+ * \param [in] mask The mask to be applied to the Non-linear function. <tt>\ref VX_MATRIX_ORIGIN</tt> attribute is used
+ *  to place the mask appropriately when computing the resulting image. See <tt>\ref vxCreateMatrixFromPattern</tt>.
  * \param [out] output The output image in <tt>\ref VX_DF_IMAGE_U8</tt> format.
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt> 
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  * \ingroup group_vision_function_nonlinear_filter
  */
 VX_API_ENTRY vx_node VX_API_CALL vxNonLinearFilterNode(vx_graph graph, vx_enum function, vx_image input, vx_matrix mask, vx_image output);
@@ -280,7 +280,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxNonLi
  * \param [out] output The output image in <tt>\ref VX_DF_IMAGE_U8</tt> or <tt>\ref VX_DF_IMAGE_S16</tt> format.
  * \ingroup group_vision_function_custom_convolution
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt> 
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxConvolveNode(vx_graph graph, vx_image input, vx_convolution conv, vx_image output);
 
@@ -291,7 +291,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxConvo
  * \ingroup group_vision_function_gaussian_pyramid
  * \see group_pyramid
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxGaussianPyramidNode(vx_graph graph, vx_image input, vx_pyramid gaussian);
 
@@ -303,7 +303,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxGauss
  * \ingroup group_vision_function_laplacian_pyramid
  * \see group_pyramid
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxLaplacianPyramidNode(vx_graph graph, vx_image input,
                                    vx_pyramid laplacian, vx_image output);
@@ -328,7 +328,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxLapla
  * \param [in,out] accum The accumulation image in <tt>\ref VX_DF_IMAGE_S16</tt>.
  * \ingroup group_vision_function_accumulate
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxAccumulateImageNode(vx_graph graph, vx_image input, vx_image accum);
 
@@ -339,7 +339,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxAccum
  * \param [in,out] accum The <tt>\ref VX_DF_IMAGE_U8</tt> accumulation image.
  * \ingroup group_vision_function_accumulate_weighted
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxAccumulateWeightedImageNode(vx_graph graph, vx_image input, vx_scalar alpha, vx_image accum);
 
@@ -350,7 +350,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxAccum
  * \param [in,out] accum The accumulation image in <tt>\ref VX_DF_IMAGE_S16</tt>.
  * \ingroup group_vision_function_accumulate_square
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxAccumulateSquareImageNode(vx_graph graph, vx_image input, vx_scalar shift, vx_image accum);
 
@@ -365,7 +365,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxAccum
  * \param [out] maxCount The total number of detected maximums in image (optional). Use a <tt>\ref VX_TYPE_UINT32</tt> scalar.
  * \ingroup group_vision_function_minmaxloc
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxMinMaxLocNode(vx_graph graph,
                         vx_image input,
@@ -380,7 +380,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxMinMa
  * \param [out] out The <tt>\ref VX_DF_IMAGE_U8</tt> output image.
  * \ingroup group_vision_function_and
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxAndNode(vx_graph graph, vx_image in1, vx_image in2, vx_image out);
 
@@ -391,7 +391,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxAndNo
  * \param [out] out The <tt>\ref VX_DF_IMAGE_U8</tt> output image.
  * \ingroup group_vision_function_or
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxOrNode(vx_graph graph, vx_image in1, vx_image in2, vx_image out);
 
@@ -402,7 +402,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxOrNod
  * \param [out] out The <tt>\ref VX_DF_IMAGE_U8</tt> output image.
  * \ingroup group_vision_function_xor
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxXorNode(vx_graph graph, vx_image in1, vx_image in2, vx_image out);
 
@@ -412,7 +412,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxXorNo
  * \param [out] output The <tt>\ref VX_DF_IMAGE_U8</tt> output image.
  * \ingroup group_vision_function_not
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxNotNode(vx_graph graph, vx_image input, vx_image output);
 
@@ -426,7 +426,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxNotNo
  * \param [out] out The output image, a <tt>\ref VX_DF_IMAGE_U8</tt> or <tt>\ref VX_DF_IMAGE_S16</tt> image.
  * \ingroup group_vision_function_mult
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxMultiplyNode(vx_graph graph,
                        vx_image in1, vx_image in2,
@@ -443,7 +443,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxMulti
  * \param [out] out The output image, a <tt>\ref VX_DF_IMAGE_U8</tt> or <tt>\ref VX_DF_IMAGE_S16</tt> image.
  * \ingroup group_vision_function_add
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxAddNode(vx_graph graph,
                   vx_image in1, vx_image in2,
@@ -458,7 +458,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxAddNo
  * \param [out] out The output image, a <tt>\ref VX_DF_IMAGE_U8</tt> or <tt>\ref VX_DF_IMAGE_S16</tt> image.
  * \ingroup group_vision_function_sub
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxSubtractNode(vx_graph graph,
                        vx_image in1, vx_image in2,
@@ -473,23 +473,23 @@ VX_API_ENTRY vx_node VX_API_CALL vxSubtr
  * \param [in] shift A scalar containing a <tt>\ref VX_TYPE_INT32</tt> of the shift value.
  * \ingroup group_vision_function_convertdepth
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxConvertDepthNode(vx_graph graph, vx_image input, vx_image output, vx_enum policy, vx_scalar shift);
 
 /*! \brief [Graph] Creates a Canny Edge Detection Node.
  * \param [in] graph The reference to the graph.
  * \param [in] input The input <tt>\ref VX_DF_IMAGE_U8</tt> image.
- * \param [in] hyst The double threshold for hysteresis. The threshold data_type shall be either <tt>\ref VX_TYPE_UINT8</tt> 
- * or <tt>\ref VX_TYPE_INT16</tt>. The <tt>\ref VX_THRESHOLD_TRUE_VALUE</tt> and <tt>\ref VX_THRESHOLD_FALSE_VALUE</tt> 
+ * \param [in] hyst The double threshold for hysteresis. The threshold data_type shall be either <tt>\ref VX_TYPE_UINT8</tt>
+ * or <tt>\ref VX_TYPE_INT16</tt>. The <tt>\ref VX_THRESHOLD_TRUE_VALUE</tt> and <tt>\ref VX_THRESHOLD_FALSE_VALUE</tt>
  * of <tt>\ref vx_threshold</tt> are ignored.
  * \param [in] gradient_size The size of the Sobel filter window, must support at least 3, 5, and 7.
  * \param [in] norm_type A flag indicating the norm used to compute the gradient, <tt>\ref VX_NORM_L1</tt> or VX_NORM_L2.
- * \param [out] output The output image in <tt>\ref VX_DF_IMAGE_U8</tt> format with values either 
+ * \param [out] output The output image in <tt>\ref VX_DF_IMAGE_U8</tt> format with values either
  * <tt>\ref VX_THRESHOLD_TRUE_VALUE</tt> or <tt>\ref VX_THRESHOLD_FALSE_VALUE</tt> from hyst parameter.
  * \ingroup group_vision_function_canny
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxCannyEdgeDetectorNode(vx_graph graph, vx_image input, vx_threshold hyst,
                                 vx_int32 gradient_size, vx_enum norm_type,
@@ -506,7 +506,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxCanny
  * \note The border modes <tt>\ref VX_NODE_BORDER</tt> value <tt>\ref VX_BORDER_UNDEFINED</tt> and
  * <tt>\ref VX_BORDER_CONSTANT</tt> are supported.
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxWarpAffineNode(vx_graph graph, vx_image input, vx_matrix matrix, vx_enum type, vx_image output);
 
@@ -518,10 +518,10 @@ VX_API_ENTRY vx_node VX_API_CALL vxWarpA
  * <tt>\ref VX_INTERPOLATION_AREA</tt> is not supported.
  * \param [out] output The output <tt>\ref VX_DF_IMAGE_U8</tt> image.
  * \ingroup group_vision_function_warp_perspective
- * \note The border modes <tt>\ref VX_NODE_BORDER</tt> value <tt>\ref VX_BORDER_UNDEFINED</tt> and 
+ * \note The border modes <tt>\ref VX_NODE_BORDER</tt> value <tt>\ref VX_BORDER_UNDEFINED</tt> and
  * <tt>\ref VX_BORDER_CONSTANT</tt> are supported.
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxWarpPerspectiveNode(vx_graph graph, vx_image input, vx_matrix matrix, vx_enum type, vx_image output);
 
@@ -539,7 +539,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxWarpP
  * \param [out] num_corners The total number of detected corners in image (optional). Use a \ref VX_TYPE_SIZE scalar.
  * \ingroup group_vision_function_harris
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxHarrisCornersNode(vx_graph graph,
                             vx_image input,
@@ -557,12 +557,12 @@ VX_API_ENTRY vx_node VX_API_CALL vxHarri
  * \param [in] strength_thresh Threshold on difference between intensity of the central pixel and pixels on Bresenham's circle of radius 3 (<tt>\ref VX_TYPE_FLOAT32</tt> scalar).
  * \param [in] nonmax_suppression If true, non-maximum suppression is applied to
  * detected corners before being placed in the <tt>\ref vx_array</tt> of <tt>\ref VX_TYPE_KEYPOINT</tt> objects.
- * \param [out] corners Output corner <tt>\ref vx_array</tt> of <tt>\ref VX_TYPE_KEYPOINT</tt>. The order of the 
+ * \param [out] corners Output corner <tt>\ref vx_array</tt> of <tt>\ref VX_TYPE_KEYPOINT</tt>. The order of the
  *                      keypoints in this array is implementation dependent.
  * \param [out] num_corners The total number of detected corners in image (optional). Use a \ref VX_TYPE_SIZE scalar.
  * \ingroup group_vision_function_fast
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxFastCornersNode(vx_graph graph, vx_image input, vx_scalar strength_thresh, vx_bool nonmax_suppression, vx_array corners, vx_scalar num_corners);
 
@@ -581,11 +581,11 @@ VX_API_ENTRY vx_node VX_API_CALL vxFastC
  * \param [in] epsilon The <tt>\ref vx_float32</tt> error for terminating the algorithm.
  * \param [in] num_iterations The number of iterations. Use a <tt>\ref VX_TYPE_UINT32</tt> scalar.
  * \param [in] use_initial_estimate Use a <tt>\ref VX_TYPE_BOOL</tt> scalar.
- * \param [in] window_dimension The size of the window on which to perform the algorithm. See 
+ * \param [in] window_dimension The size of the window on which to perform the algorithm. See
  *  <tt>\ref VX_CONTEXT_OPTICAL_FLOW_MAX_WINDOW_DIMENSION</tt>
  * \ingroup group_vision_function_opticalflowpyrlk
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxOpticalFlowPyrLKNode(vx_graph graph,
                                vx_pyramid old_images,
@@ -606,10 +606,10 @@ VX_API_ENTRY vx_node VX_API_CALL vxOptic
  * \param [in] policy An interpolation type from <tt>\ref vx_interpolation_type_e</tt>.
  * <tt>\ref VX_INTERPOLATION_AREA</tt> is not supported.
  * \param [out] output The output <tt>\ref VX_DF_IMAGE_U8</tt> image.
- * \note The border modes <tt>\ref VX_NODE_BORDER</tt> value <tt>\ref VX_BORDER_UNDEFINED</tt> and 
+ * \note The border modes <tt>\ref VX_NODE_BORDER</tt> value <tt>\ref VX_BORDER_UNDEFINED</tt> and
  * <tt>\ref VX_BORDER_CONSTANT</tt> are supported.
  * \return A <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  * \ingroup group_vision_function_remap
  */
 VX_API_ENTRY vx_node VX_API_CALL vxRemapNode(vx_graph graph,
@@ -628,13 +628,55 @@ VX_API_ENTRY vx_node VX_API_CALL vxRemap
  * \param [in] graph The reference to the graph.
  * \param [in] input The input <tt>\ref VX_DF_IMAGE_U8</tt> image.
  * \param [out] output The output <tt>\ref VX_DF_IMAGE_U8</tt> image.
- * \param [in] kernel_size The input size of the Gaussian filter. Supported values are 1, 3 and 5. 
+ * \param [in] kernel_size The input size of the Gaussian filter. Supported values are 1, 3 and 5.
  * \ingroup group_vision_function_scale_image
  * \return <tt>\ref vx_node</tt>.
- * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>  
+ * \retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\ref vxGetStatus</tt>
  */
 VX_API_ENTRY vx_node VX_API_CALL vxHalfScaleGaussianNode(vx_graph graph, vx_image input, vx_image output, vx_int32 kernel_size);
 
+/*! \brief [Graph] Pick keypoints using SIFT feature algorithms.
+* \details will add keypoint (x, y, o, scale) to keypointarr.
+* \param [in] graph The reference to the graph.
+* \param [in] img_octave The input <tt>\ref VX_DF_IMAGE_S16</tt> image arrat pointer
+* \param [in] octave The input <tt>\ref VX_INT32</tt> octave, index of that octave containing 3 given layers.
+* \param [out] arr will contain recently found keypoint. 1 keypoint.
+* \ingroup group_kernel_findingsift
+* \return <tt>\ref vx_node</tt>.
+* \retval 0 Node could not be created.
+* \retval * Node handle.
+*/
+VX_API_ENTRY vx_node VX_API_CALL vxFindSiftKeypointNode(vx_graph graph, vx_image prev, vx_image curr, vx_image next,
+	vx_int32 octave, vx_int32 maximum, vx_array arr);
+
+/*! \brief [Graph] Pick keypoints using SIFT feature algorithms.
+* \details will add keypoint (x, y, o, scale) to keypointarr.
+* \param [in] graph The reference to the graph.
+* \param [in] array The input keypoints
+* \param [in] image The input x
+* \param [in] image The input y
+* \param [out] array2 recently verified keypoints
+* \ingroup group_verify_keypoint
+* \return <tt>\ref vx_node</tt>.
+* \retval 0 Node could not be created.
+* \retval * Node handle.
+*/
+VX_API_ENTRY vx_node VX_API_CALL vxVerifyKeypointNode(vx_graph graph, vx_array before, vx_image mag, vx_int32 w, vx_int32 h, vx_int32 maximum, vx_array after, vx_image keyptimg);
+
+/*! \brief [Graph] Pick keypoints using SIFT feature algorithms.
+* \details will add keypoint (x, y, o, scale) to keypointarr.
+* \param [in] graph The reference to the graph.
+* \param [in] array The input keypoints
+* \param [in] image The input x
+* \param [in] image The input y
+* \param [out] array2 recently verified keypoints
+* \ingroup group_calc_sift_gradient
+* \return <tt>\ref vx_node</tt>.
+* \retval 0 Node could not be created.
+* \retval * Node handle.
+*/
+VX_API_ENTRY vx_node VX_API_CALL vxCalcSiftGradientNode(vx_graph graph, vx_image orient, vx_image magni, vx_array keypt, vx_array descr);
+
 #ifdef __cplusplus
 }
 #endif
diff -Npur -x '.*' a/include/VX/vx_types.h b/include/VX/vx_types.h
--- a/include/VX/vx_types.h	2016-06-17 10:02:32.000000000 -0700
+++ b/include/VX/vx_types.h	2016-08-08 16:54:52.000000000 -0700
@@ -1,4 +1,4 @@
-/* 
+/*
  * Copyright (c) 2012-2016 The Khronos Group Inc.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
@@ -270,7 +270,7 @@ typedef struct _vx_remap *vx_remap;
  */
 typedef struct _vx_array *vx_array;
 
-/*! \brief The ObjectArray Object. ObjectArray is a strongly-typed container of OpenVX data-objects. 
+/*! \brief The ObjectArray Object. ObjectArray is a strongly-typed container of OpenVX data-objects.
  * \ingroup group_object_array
  */
 typedef struct _vx_object_array *vx_object_array;
@@ -294,12 +294,12 @@ typedef enum _vx_bool_e {
 } vx_bool;
 
 /*!
- * \brief This object is used by output validation functions to specify the meta data 
- * of the expected output data object. 
- * \note When the actual output object of the user node is virtual, the information 
- * given through the vx_meta_format object allows the OpenVX framework to automatically 
- * create the data object when meta data were not specified by the application at object 
- * creation time. 
+ * \brief This object is used by output validation functions to specify the meta data
+ * of the expected output data object.
+ * \note When the actual output object of the user node is virtual, the information
+ * given through the vx_meta_format object allows the OpenVX framework to automatically
+ * create the data object when meta data were not specified by the application at object
+ * creation time.
  * \ingroup group_user_kernels
  */
 typedef struct _vx_meta_format* vx_meta_format;
@@ -733,7 +733,7 @@ enum vx_target_e {
     /*! \brief Target, explicitly specified by its (case-insensitive) name string. */
     VX_TARGET_STRING = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_TARGET) + 0x0001,
     /*! \brief Start of Vendor specific target enumerates. */
-    VX_TARGET_VENDOR_BEGIN = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_TARGET) + 0x1000, 
+    VX_TARGET_VENDOR_BEGIN = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_TARGET) + 0x1000,
 };
 
 /*! \brief The reference attributes list.
@@ -768,8 +768,8 @@ enum vx_context_attribute_e {
     VX_CONTEXT_EXTENSIONS_SIZE = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_CONTEXT) + 0x6,
     /*! \brief Retrieves the extensions string. Read-only.
      * This is a space-separated string of extension names. Each OpenVX official extension has a unique identifier,
-     * comprised of capital letters, numbers and the underscore character, prefixed with "KHR_", for example "KHR_NEW_FEATURE". 
-     * Use a <tt>\ref vx_char</tt> pointer allocated to the size returned from <tt>\ref VX_CONTEXT_EXTENSIONS_SIZE</tt>. 
+     * comprised of capital letters, numbers and the underscore character, prefixed with "KHR_", for example "KHR_NEW_FEATURE".
+     * Use a <tt>\ref vx_char</tt> pointer allocated to the size returned from <tt>\ref VX_CONTEXT_EXTENSIONS_SIZE</tt>.
      */
     VX_CONTEXT_EXTENSIONS = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_CONTEXT) + 0x7,
     /*! \brief The maximum width or height of a convolution matrix.
@@ -799,14 +799,14 @@ enum vx_context_attribute_e {
      */
     VX_CONTEXT_UNIQUE_KERNEL_TABLE = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_CONTEXT) + 0xB,
     /*! \brief The unsupported border mode policy for immediate mode functions. Read-only.
-     *  
+     *
      * \details Graph mode functions are unaffected by this attribute. Use a <tt>\ref vx_enum</tt> as parameter.
      * \note The assumed default value for immediate mode functions is <tt>\ref VX_BORDER_POLICY_DEFAULT_TO_UNDEFINED</tt>.
      */
     VX_CONTEXT_IMMEDIATE_BORDER_POLICY = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_CONTEXT) + 0xC,
     /*! \brief The dimension of the largest nonlinear filter supported. See <tt>\ref vxNonLinearFilterNode</tt>.
-     * \details The implementation must support all dimensions (height or width, not necessarily the same) 
-     * up to the value of this attribute.  The lowest value that must be supported for this attribute is 9. 
+     * \details The implementation must support all dimensions (height or width, not necessarily the same)
+     * up to the value of this attribute.  The lowest value that must be supported for this attribute is 9.
      * Read-only. Use a <tt>\ref vx_size</tt> parameter.
      */
     VX_CONTEXT_NONLINEAR_MAX_DIMENSION = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_CONTEXT) + 0xd,
@@ -844,8 +844,8 @@ enum vx_node_attribute_e {
     VX_NODE_STATUS = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_NODE) + 0x0,
     /*! \brief Queries the performance of the node execution.
      * The accuracy of timing information is platform dependent and also depends on the graph
-     * optimizations. Read-only. 
-     * \note Performance tracking must have been enabled. See <tt>\ref vx_directive_e</tt>. 
+     * optimizations. Read-only.
+     * \note Performance tracking must have been enabled. See <tt>\ref vx_directive_e</tt>.
      */
     VX_NODE_PERFORMANCE = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_NODE) + 0x1,
     /*! \brief Gets or sets the border mode of the node.
@@ -866,15 +866,15 @@ enum vx_node_attribute_e {
      * Read-only. Use a <tt>\ref vx_uint32</tt> parameter.
      */
     VX_NODE_PARAMETERS = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_NODE) + 0x5,
-    /*! \brief Indicates whether the node is replicated. Read-only. 
+    /*! \brief Indicates whether the node is replicated. Read-only.
      * Use a <tt>\ref vx_bool</tt> parameter.
      */
     VX_NODE_IS_REPLICATED = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_NODE) + 0x6,
-    /*! \brief Indicates the replicated parameters. Read-only. 
+    /*! \brief Indicates the replicated parameters. Read-only.
      * Use a <tt>\ref vx_bool</tt>* parameter.
      */
     VX_NODE_REPLICATE_FLAGS = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_NODE) + 0x7,
-    /*! \brief Indicates the behavior with respect to the valid rectangle. Read-only. 
+    /*! \brief Indicates the behavior with respect to the valid rectangle. Read-only.
      * Use a <tt>\ref vx_bool</tt> parameter.
      */
     VX_NODE_VALID_RECT_RESET = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_NODE) + 0x8,
@@ -914,7 +914,7 @@ enum vx_image_attribute_e {
     VX_IMAGE_RANGE = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_IMAGE) + 0x5,
     /*! \brief Queries an image for its total number of bytes. Read-only. Use a <tt>\ref vx_size</tt> parameter. */
     VX_IMAGE_SIZE = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_IMAGE) + 0x6,
-    /*! \brief Queries memory type if created using vxCreateImageFromHandle. If vx_image was not created using 
+    /*! \brief Queries memory type if created using vxCreateImageFromHandle. If vx_image was not created using
         vxCreateImageFromHandle, VX_MEMORY_TYPE_NONE is returned. Use a <tt>\ref vx_memory_type_e</tt> parameter. */
     VX_IMAGE_MEMORY_TYPE = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_IMAGE) + 0x7,
 };
@@ -949,11 +949,11 @@ enum vx_distribution_attribute_e {
     VX_DISTRIBUTION_DIMENSIONS = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_DISTRIBUTION) + 0x0,
     /*! \brief Indicates the start of the values to use (inclusive). Read-only. Use a <tt>\ref vx_int32</tt> parameter. */
     VX_DISTRIBUTION_OFFSET = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_DISTRIBUTION) + 0x1,
-    /*! \brief Indicates the total number of the consecutive values of the distribution interval. */ 
+    /*! \brief Indicates the total number of the consecutive values of the distribution interval. */
     VX_DISTRIBUTION_RANGE = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_DISTRIBUTION) + 0x2,
     /*! \brief Indicates the number of bins. Read-only. Use a <tt>\ref vx_size</tt> parameter. */
     VX_DISTRIBUTION_BINS = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_DISTRIBUTION) + 0x3,
-    /*! \brief Indicates the width of a bin. Equal to the range divided by the number of bins. If the range is not a 
+    /*! \brief Indicates the width of a bin. Equal to the range divided by the number of bins. If the range is not a
      * multiple of the number of bins, it is not valid. Read-only. Use a <tt>\ref vx_uint32</tt> parameter.  */
     VX_DISTRIBUTION_WINDOW = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_DISTRIBUTION) + 0x4,
     /*! \brief Indicates the total size of the distribution in bytes. Read-only. Use a <tt>\ref vx_size</tt> parameter. */
@@ -1002,7 +1002,7 @@ enum vx_matrix_attribute_e {
     VX_MATRIX_COLUMNS = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_MATRIX) + 0x2,
     /*! \brief The total size of the matrix in bytes. Read-only. Use a <tt>\ref vx_size</tt> parameter. */
     VX_MATRIX_SIZE = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_MATRIX) + 0x3,
-    /*! \brief The origin of the matrix with a default value of [floor(VX_MATRIX_COLUMNS/2), 
+    /*! \brief The origin of the matrix with a default value of [floor(VX_MATRIX_COLUMNS/2),
          floor(VX_MATRIX_ROWS/2)]. Read-only. Use a <tt>\ref vx_coordinates2d_t</tt> parameter. */
     VX_MATRIX_ORIGIN = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_MATRIX) + 0x4,
     /*! \brief The pattern of the matrix. See <tt>\ref vx_pattern_e </tt>. Read-only. Use a <tt>\ref vx_enum</tt> parameter. */
@@ -1173,9 +1173,9 @@ enum vx_non_linear_filter_e {
     /*! \brief Nonlinear median filter. */
     VX_NONLINEAR_FILTER_MEDIAN = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_NONLINEAR) + 0x0,
     /*! \brief Nonlinear Erode. */
-    VX_NONLINEAR_FILTER_MIN = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_NONLINEAR) + 0x1 , 
+    VX_NONLINEAR_FILTER_MIN = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_NONLINEAR) + 0x1 ,
     /*! \brief Nonlinear Dilate. */
-    VX_NONLINEAR_FILTER_MAX = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_NONLINEAR) + 0x2, 
+    VX_NONLINEAR_FILTER_MAX = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_NONLINEAR) + 0x2,
 };
 
 /*! \brief An enumeration of matrix patterns. See <tt>\ref vxCreateMatrixFromPattern </tt>
@@ -1625,4 +1625,13 @@ enum vx_map_flag_e {
      VX_NOGAP_X = 1,  /*!< \brief No Gap. */
 };
 
+/*!\brief This structure is used to sift feature
+* \ingroup group_user_kernels
+*/
+typedef struct _vx_siftfeature {
+    vx_coordinates2d_t point; /*!< \brief The keypoint X,Y pos. */
+    vx_float32 orientation;   /*!< \brief The orientation of keypoint */
+    vx_int16 discriptor[128]; /*!< \brief The 128 array size discriptor of keypoint */
+} vx_siftfeature;
+
 #endif
diff -Npur -x '.*' a/include/VX/vxu.h b/include/VX/vxu.h
--- a/include/VX/vxu.h	2016-06-17 10:02:32.000000000 -0700
+++ b/include/VX/vxu.h	2016-08-08 16:02:10.000000000 -0700
@@ -1,4 +1,4 @@
-/* 
+/*
  * Copyright (c) 2012-2016 The Khronos Group Inc.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
@@ -186,7 +186,7 @@ VX_API_ENTRY vx_status VX_API_CALL vxuMe
  * \param [in] input The input image. <tt>\ref VX_DF_IMAGE_U8</tt> is supported.
  * \param [in] thresh The thresholding object that defines the parameters of
  * the operation. The <tt>\ref VX_THRESHOLD_TRUE_VALUE</tt> and <tt>\ref VX_THRESHOLD_FALSE_VALUE</tt> are taken into account.
- * \param [out] output The output Boolean image with values either <tt>\ref VX_THRESHOLD_TRUE_VALUE</tt> or 
+ * \param [out] output The output Boolean image with values either <tt>\ref VX_THRESHOLD_TRUE_VALUE</tt> or
  * <tt>\ref VX_THRESHOLD_FALSE_VALUE</tt> from the \e thresh parameter.
  * \ingroup group_vision_function_threshold
  * \return A <tt>\ref vx_status_e</tt> enumeration.
@@ -265,8 +265,8 @@ VX_API_ENTRY vx_status VX_API_CALL vxuGa
  * \param [in] context The reference to the overall context.
  * \param [in] function The non-linear filter function. See <tt>\ref vx_non_linear_filter_e</tt>.
  * \param [in] input The input image in <tt>\ref VX_DF_IMAGE_U8</tt> format.
- * \param [in] mask The mask to be applied to the Non-linear function. <tt>\ref VX_MATRIX_ORIGIN</tt> attribute is used 
- * to place the mask appropriately when computing the resulting image. See <tt>\ref vxCreateMatrixFromPattern</tt>.  
+ * \param [in] mask The mask to be applied to the Non-linear function. <tt>\ref VX_MATRIX_ORIGIN</tt> attribute is used
+ * to place the mask appropriately when computing the resulting image. See <tt>\ref vxCreateMatrixFromPattern</tt>.
  * \param [out] output The output image in <tt>\ref VX_DF_IMAGE_U8</tt> format.
  * \return A <tt>\ref vx_status_e</tt> enumeration.
  * \retval VX_SUCCESS Success
@@ -397,12 +397,12 @@ VX_API_ENTRY vx_status VX_API_CALL vxuCo
 /*! \brief [Immediate] Computes Canny Edges on the input image into the output image.
  * \param [in] context The reference to the overall context.
  * \param [in] input The input <tt>\ref VX_DF_IMAGE_U8</tt> image.
- * \param [in] hyst The double threshold for hysteresis. The threshold data_type shall be either <tt>\ref VX_TYPE_UINT8</tt> 
- * or <tt>\ref VX_TYPE_INT16</tt>. The <tt>\ref VX_THRESHOLD_TRUE_VALUE</tt> and <tt>\ref VX_THRESHOLD_FALSE_VALUE</tt> 
+ * \param [in] hyst The double threshold for hysteresis. The threshold data_type shall be either <tt>\ref VX_TYPE_UINT8</tt>
+ * or <tt>\ref VX_TYPE_INT16</tt>. The <tt>\ref VX_THRESHOLD_TRUE_VALUE</tt> and <tt>\ref VX_THRESHOLD_FALSE_VALUE</tt>
  * of <tt>\ref vx_threshold</tt> are ignored.
  * \param [in] gradient_size The size of the Sobel filter window, must support at least 3, 5 and 7.
  * \param [in] norm_type A flag indicating the norm used to compute the gradient, VX_NORM_L1 or VX_NORM_L2.
- * \param [out] output The output image in <tt>\ref VX_DF_IMAGE_U8</tt> format with values either 
+ * \param [out] output The output image in <tt>\ref VX_DF_IMAGE_U8</tt> format with values either
  * <tt>\ref VX_THRESHOLD_TRUE_VALUE</tt> or <tt>\ref VX_THRESHOLD_FALSE_VALUE</tt> from hyst parameter.
  * \ingroup group_vision_function_canny
  * \return A <tt>\ref vx_status_e</tt> enumeration.
@@ -599,7 +599,7 @@ VX_API_ENTRY vx_status VX_API_CALL vxuFa
  * \param [in] epsilon is the <tt>\ref vx_float32</tt> error for terminating the algorithm
  * \param [in] num_iterations is the number of iterations. Use a <tt>\ref VX_TYPE_UINT32</tt> scalar.
  * \param [in] use_initial_estimate Can be set to either <tt>\ref vx_false_e</tt> or <tt>\ref vx_true_e</tt>.
- * \param [in] window_dimension The size of the window on which to perform the algorithm. See 
+ * \param [in] window_dimension The size of the window on which to perform the algorithm. See
  *  <tt>\ref VX_CONTEXT_OPTICAL_FLOW_MAX_WINDOW_DIMENSION</tt>
  *
  * \ingroup group_vision_function_opticalflowpyrlk
@@ -635,6 +635,55 @@ VX_API_ENTRY vx_status VX_API_CALL vxuRe
                   vx_enum policy,
                   vx_image output);
 
+/*! \brief [Immediate] Pick keypoints using SIFT feature algorithms.
+* \param [in] context The reference to the overall context.
+* \param [in] img_octave The input <tt>\ref VX_DF_IMAGE_S16</tt> image arrat pointer
+* \param [in] octave The input <tt>\ref VX_INT32</tt> octave, index of that octave containing 3 given layers.
+* \param [out] arr will contain recently found keypoint. 1 keypoint.
+* \return A <tt>\ref vx_status_e</tt> enumeration.
+* \ingroup group_kernel_findingsift
+*/
+VX_API_ENTRY vx_status VX_API_CALL vxuFindSiftKeypoint(vx_context context,
+                  vx_image prev,
+                  vx_image curr,
+                  vx_image next,
+                  vx_int32 octave,
+                  vx_int32 maximum,
+                  vx_array arr);
+
+/*! \brief [Immediate] Pick keypoints using SIFT feature algorithms.
+* \param [in] context The reference to the overall context.
+* \param [in] array The input keypoints
+* \param [in] image The input x
+* \param [in] image The input y
+* \param [out] array2 recently verified keypoints
+* \return A <tt>\ref vx_status_e</tt> enumeration.
+* \ingroup group_verify_keypoint
+*/
+VX_API_ENTRY vx_status VX_API_CALL vxuVerifyKeypoint(vx_context context,
+                  vx_array before,
+                  vx_image mag,
+                  vx_int32 w,
+                  vx_int32 h,
+                  vx_int32 maximum,
+                  vx_array after,
+                  vx_image keyptimg);
+
+/*! \brief [Immediate] calculate descriptors using SIFT keypoints using phase of gardient
+* \param [in] context The reference to the overall context.
+* \param [in] array The input keypoints
+* \param [in] image The input x
+* \param [in] image The input y
+* \param [out] array2 recently verified keypoints
+* \return A <tt>\ref vx_status_e</tt> enumeration.
+* \ingroup group_calc_sift_gradient
+*/
+VX_API_ENTRY vx_status VX_API_CALL vxuCalcSiftGradient(vx_context context,
+                  vx_image orient,
+                  vx_image magni,
+                  vx_array keypt,
+                  vx_array descr);
+
 #ifdef __cplusplus
 }
 #endif
diff -Npur -x '.*' a/kernels/c_model/CMakeLists.txt b/kernels/c_model/CMakeLists.txt
--- a/kernels/c_model/CMakeLists.txt	2016-06-17 10:02:15.000000000 -0700
+++ b/kernels/c_model/CMakeLists.txt	2016-08-07 20:39:29.000000000 -0700
@@ -34,7 +34,7 @@ include_directories( BEFORE
                      ${CMAKE_CURRENT_SOURCE_DIR}
                      ${CMAKE_SOURCE_DIR}/include
                      ${CMAKE_SOURCE_DIR}/debug )
-					 
+
 FIND_SOURCES()
 
 # add a target named ${TARGET_NAME}
@@ -42,9 +42,9 @@ add_library (${TARGET_NAME} ${SOURCE_FIL
 
 target_link_libraries( ${TARGET_NAME} openvx )
 
-install ( TARGETS ${TARGET_NAME} 
+install ( TARGETS ${TARGET_NAME}
           RUNTIME DESTINATION bin
-          ARCHIVE DESTINATION bin
-          LIBRARY DESTINATION bin )
-		  
+          ARCHIVE DESTINATION lib
+          LIBRARY DESTINATION lib )
+
 set_target_properties( ${TARGET_NAME} PROPERTIES FOLDER ${KERNELS_FOLDER} )
diff -Npur -x '.*' a/kernels/debug/CMakeLists.txt b/kernels/debug/CMakeLists.txt
--- a/kernels/debug/CMakeLists.txt	2016-06-17 10:02:15.000000000 -0700
+++ b/kernels/debug/CMakeLists.txt	2016-08-07 20:39:02.000000000 -0700
@@ -39,9 +39,9 @@ FIND_SOURCES()
 # add a target named ${TARGET_NAME}
 add_library (${TARGET_NAME} ${SOURCE_FILES})
 
-install ( TARGETS ${TARGET_NAME} 
+install ( TARGETS ${TARGET_NAME}
           RUNTIME DESTINATION bin
-          ARCHIVE DESTINATION bin
-          LIBRARY DESTINATION bin )
-		  
+          ARCHIVE DESTINATION lib
+          LIBRARY DESTINATION lib )
+
 set_target_properties( ${TARGET_NAME} PROPERTIES FOLDER ${KERNELS_FOLDER} )
diff -Npur -x '.*' a/kernels/extras/CMakeLists.txt b/kernels/extras/CMakeLists.txt
--- a/kernels/extras/CMakeLists.txt	2016-06-17 10:02:15.000000000 -0700
+++ b/kernels/extras/CMakeLists.txt	2016-08-07 20:39:44.000000000 -0700
@@ -39,9 +39,9 @@ FIND_SOURCES()
 # add a target named ${TARGET_NAME}
 add_library (${TARGET_NAME} ${SOURCE_FILES})
 
-install ( TARGETS ${TARGET_NAME} 
+install ( TARGETS ${TARGET_NAME}
           RUNTIME DESTINATION bin
-          ARCHIVE DESTINATION bin
-          LIBRARY DESTINATION bin )
-		  
+          ARCHIVE DESTINATION lib
+          LIBRARY DESTINATION lib )
+
 set_target_properties( ${TARGET_NAME} PROPERTIES FOLDER ${KERNELS_FOLDER} )
diff -Npur -x '.*' a/libraries/debug/CMakeLists.txt b/libraries/debug/CMakeLists.txt
--- a/libraries/debug/CMakeLists.txt	2016-06-17 10:02:15.000000000 -0700
+++ b/libraries/debug/CMakeLists.txt	2016-08-07 20:40:18.000000000 -0700
@@ -35,7 +35,7 @@ include_directories( BEFORE
                      ${CMAKE_CURRENT_SOURCE_DIR}
                      ${CMAKE_SOURCE_DIR}/include
                      ${CMAKE_SOURCE_DIR}/kernels/debug )
-					 
+
 if ((WIN32) OR (CYGWIN))
    add_definitions( ${OPENVX_BUILDING_EXPORT_DEF} )
 endif ((WIN32) OR (CYGWIN))
@@ -59,8 +59,8 @@ target_link_libraries( ${TARGET_NAME_2}
 
 install ( TARGETS ${TARGET_NAME_1} ${TARGET_NAME_2}
           RUNTIME DESTINATION bin
-          ARCHIVE DESTINATION bin
-          LIBRARY DESTINATION bin )
-		  
+          ARCHIVE DESTINATION lib
+          LIBRARY DESTINATION lib )
+
 set_target_properties( ${TARGET_NAME_1} PROPERTIES FOLDER ${LIBRARIES_DEBUG_FOLDER} )
 set_target_properties( ${TARGET_NAME_2} PROPERTIES FOLDER ${LIBRARIES_DEBUG_FOLDER} )
diff -Npur -x '.*' a/libraries/extras/CMakeLists.txt b/libraries/extras/CMakeLists.txt
--- a/libraries/extras/CMakeLists.txt	2016-06-17 10:02:15.000000000 -0700
+++ b/libraries/extras/CMakeLists.txt	2016-08-07 20:40:36.000000000 -0700
@@ -39,7 +39,7 @@ include_directories( BEFORE
 if ((WIN32) OR (CYGWIN))
    add_definitions( ${OPENVX_BUILDING_EXPORT_DEF} )
 endif ((WIN32) OR (CYGWIN))
-					 
+
 # add a target named ${TARGET_NAME}
 add_library (${TARGET_NAME_1} vx_extras_lib.c)
 
@@ -61,8 +61,8 @@ target_link_libraries( ${TARGET_NAME_2}
 
 install ( TARGETS ${TARGET_NAME_1} ${TARGET_NAME_2}
           RUNTIME DESTINATION bin
-          ARCHIVE DESTINATION bin
-          LIBRARY DESTINATION bin )
-		  
+          ARCHIVE DESTINATION lib
+          LIBRARY DESTINATION lib )
+
 set_target_properties( ${TARGET_NAME_1} PROPERTIES FOLDER ${LIBRARIES_EXTRAS_FOLDER} )
 set_target_properties( ${TARGET_NAME_2} PROPERTIES FOLDER ${LIBRARIES_EXTRAS_FOLDER} )
diff -Npur -x '.*' a/sample/framework/CMakeLists.txt b/sample/framework/CMakeLists.txt
--- a/sample/framework/CMakeLists.txt	2016-06-17 10:02:32.000000000 -0700
+++ b/sample/framework/CMakeLists.txt	2016-08-07 20:44:34.000000000 -0700
@@ -33,14 +33,14 @@ set( TARGET_NAME openvx )
 include_directories( BEFORE
                      ${CMAKE_CURRENT_SOURCE_DIR}
                      ${CMAKE_CURRENT_SOURCE_DIR}/../include
-					 ${CMAKE_SOURCE_DIR}/include 
-					 ${CMAKE_SOURCE_DIR}/debug 
+					 ${CMAKE_SOURCE_DIR}/include
+					 ${CMAKE_SOURCE_DIR}/debug
 					 ${OPENCL_INCLUDE_PATH} )
-					 
+
 if ((WIN32) OR (CYGWIN))
    add_definitions( ${OPENVX_BUILDING_EXPORT_DEF} )
 endif ((WIN32) OR (CYGWIN))
-					 
+
 FIND_SOURCES()
 
 if ((WIN32) OR (CYGWIN))
@@ -57,7 +57,11 @@ if (NOT WIN32)
 	if (ANDROID)
 	    list( APPEND LINK_ADDITIONAL log )
 	else (ANDROID)
-	    list( APPEND LINK_ADDITIONAL pthread rt )
+      if (APPLE)
+        list( APPEND LINK_ADDITIONAL pthread )
+      else (APPLE)
+        list( APPEND LINK_ADDITIONAL pthread rt )
+      endif (APPLE)
 	endif (ANDROID)
 endif (NOT WIN32)
 
@@ -68,7 +72,11 @@ if (EXPERIMENTAL_USE_OPENCL)
 		    message(FATAL_ERROR "Could not find OpenCL library")
 		endif (NOT LIB_OPENCL)
 		list( APPEND LINK_ADDITIONAL ${LIB_OPENCL} )
-	endif (OPENCL_LIB_PATH)
+  else (OPENCL_LIB_PATH)
+    if (APPLE)
+      list( APPEND LINK_ADDITIONAL "-framework OpenCL" )
+    endif (APPLE)
+  endif (OPENCL_LIB_PATH)
 endif (EXPERIMENTAL_USE_OPENCL)
 
 if (CYGWIN)
@@ -77,9 +85,9 @@ endif (CYGWIN)
 
 target_link_libraries( ${TARGET_NAME} openvx-helper vx_debug ${LINK_ADDITIONAL} )
 
-install ( TARGETS ${TARGET_NAME} 
+install ( TARGETS ${TARGET_NAME}
           RUNTIME DESTINATION bin
           ARCHIVE DESTINATION lib
-          LIBRARY DESTINATION bin )
-		  
+          LIBRARY DESTINATION lib )
+
 set_target_properties( ${TARGET_NAME} PROPERTIES FOLDER ${SAMPLE_FOLDER} )
diff -Npur -x '.*' a/sample/framework/vx_node_api.c b/sample/framework/vx_node_api.c
--- a/sample/framework/vx_node_api.c	2016-06-17 10:02:32.000000000 -0700
+++ b/sample/framework/vx_node_api.c	2016-08-08 16:40:15.000000000 -0700
@@ -1,4 +1,4 @@
-/* 
+/*
  * Copyright (c) 2012-2016 The Khronos Group Inc.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
@@ -297,7 +297,7 @@ VX_API_ENTRY vx_node VX_API_CALL vxNonLi
         (vx_reference)mask,
         (vx_reference)output,
     };
-    
+
     vx_node node = vxCreateNodeByStructure(graph,
         VX_KERNEL_NON_LINEAR_FILTER,
         params,
@@ -749,3 +749,67 @@ VX_API_ENTRY vx_node VX_API_CALL vxHalfS
     vxReleaseScalar(&ksize);
     return node;
 }
+
+VX_API_ENTRY vx_node VX_API_CALL vxFindSiftKeypointNode(vx_graph graph,
+                    vx_image prev,
+                    vx_image curr,
+                    vx_image next,
+                    vx_int32 octave,
+                    vx_int32 maximum,
+                    vx_array arr)
+{
+    vx_scalar octa = vxCreateScalar(vxGetContext((vx_reference)graph), VX_TYPE_INT32, &octave);
+    vx_scalar maxi = vxCreateScalar(vxGetContext((vx_reference)graph), VX_TYPE_INT32, &maximum);
+
+	  vx_reference params[] = {
+		     (vx_reference)prev,
+		     (vx_reference)curr,
+		     (vx_reference)next,
+		     (vx_reference)octa,
+		     (vx_reference)maxi,
+		     (vx_reference)arr,
+	  };
+    vx_node node = vxCreateNodeByStructure(graph,
+                                           VX_KERNEL_FINDSIFTKEYPOINT,
+		                                       params,
+		                                       dimof(params));
+    return node;
+}
+
+VX_API_ENTRY vx_node VX_API_CALL vxVerifyKeypointNode(vx_graph graph, vx_array before, vx_image mag, vx_int32 w, vx_int32 h,
+	vx_int32 maximum, vx_array after, vx_image keyptimg)
+{
+    vx_scalar width = vxCreateScalar(vxGetContext((vx_reference)graph), VX_TYPE_INT32, &w);
+    vx_scalar height = vxCreateScalar(vxGetContext((vx_reference)graph), VX_TYPE_INT32, &h);
+    vx_scalar maxi = vxCreateScalar(vxGetContext((vx_reference)graph), VX_TYPE_INT32, &maximum);
+
+    vx_reference params[] = {
+        (vx_reference)before,
+		    (vx_reference)mag,
+		    (vx_reference)width,
+		    (vx_reference)height,
+		    (vx_reference)maxi,
+		    (vx_reference)after,
+		    (vx_reference)keyptimg,
+	  };
+    vx_node node = vxCreateNodeByStructure(graph,
+		                                       VX_KERNEL_VERIFYKEYPOINT,
+		                                       params,
+		                                       dimof(params));
+    return node;
+}
+
+VX_API_ENTRY vx_node VX_API_CALL vxCalcSiftGradientNode(vx_graph graph, vx_image orient, vx_image magni, vx_array keypt, vx_array descr)
+{
+    vx_reference params[] = {
+		    (vx_reference)orient,
+		    (vx_reference)magni,
+		    (vx_reference)keypt,
+		    (vx_reference)descr,
+    };
+    vx_node node = vxCreateNodeByStructure(graph,
+		                                       VX_KERNEL_VERIFYKEYPOINT,
+		                                       params,
+		                                       dimof(params));
+    return node;
+}
diff -Npur -x '.*' a/sample/targets/c_model/Android.mk b/sample/targets/c_model/Android.mk
--- a/sample/targets/c_model/Android.mk	2016-06-17 10:02:31.000000000 -0700
+++ b/sample/targets/c_model/Android.mk	2016-08-08 16:33:46.000000000 -0700
@@ -1,4 +1,4 @@
-# 
+#
 # Copyright (c) 2012-2016 The Khronos Group Inc.
 #
 # Permission is hereby granted, free of charge, to any person obtaining a
@@ -59,9 +59,10 @@ LOCAL_SRC_FILES := vx_interface.c \
     vx_pyramid.c \
     vx_optpyrlk.c \
     vx_scale.c \
-    vx_threshold.c
+    vx_threshold.c \
+		vx_verifykeypoint.c \
+		vx_calcsiftgradient.c
 LOCAL_C_INCLUDES := $(OPENVX_INC) $(OPENVX_TOP)/$(OPENVX_SRC)/include $(OPENVX_TOP)/$(OPENVX_SRC)/extensions/include
 LOCAL_SHARED_LIBRARIES := libdl libutils libcutils libbinder libhardware libion libgui libui libopenvx
 LOCAL_MODULE := libopenvx-c_model
 include $(BUILD_SHARED_LIBRARY)
-
diff -Npur -x '.*' a/sample/targets/c_model/CMakeLists.txt b/sample/targets/c_model/CMakeLists.txt
--- a/sample/targets/c_model/CMakeLists.txt	2016-06-17 10:02:31.000000000 -0700
+++ b/sample/targets/c_model/CMakeLists.txt	2016-08-07 20:45:12.000000000 -0700
@@ -34,7 +34,7 @@ include_directories( BEFORE
                      ${CMAKE_CURRENT_SOURCE_DIR}
 					 ${CMAKE_CURRENT_SOURCE_DIR}/../../include
 					 ${CMAKE_SOURCE_DIR}/include
-                     ${CMAKE_SOURCE_DIR}/kernels/c_model					 
+                     ${CMAKE_SOURCE_DIR}/kernels/c_model
 					 ${CMAKE_SOURCE_DIR}/debug
                      ${OPENCL_INCLUDE_PATH} )
 
@@ -53,9 +53,9 @@ endif (CYGWIN)
 
 target_link_libraries( ${TARGET_NAME} openvx-debug-lib openvx-extras-lib openvx-helper openvx-c_model-lib openvx vxu )
 
-install ( TARGETS ${TARGET_NAME} 
+install ( TARGETS ${TARGET_NAME}
           RUNTIME DESTINATION bin
           ARCHIVE DESTINATION lib
-          LIBRARY DESTINATION bin )
-		  
-set_target_properties( ${TARGET_NAME} PROPERTIES FOLDER ${SAMPLE_TARGETS_FOLDER} )
\ No newline at end of file
+          LIBRARY DESTINATION lib )
+
+set_target_properties( ${TARGET_NAME} PROPERTIES FOLDER ${SAMPLE_TARGETS_FOLDER} )
diff -Npur -x '.*' a/sample/targets/c_model/vx_calcsiftgradient.c b/sample/targets/c_model/vx_calcsiftgradient.c
--- a/sample/targets/c_model/vx_calcsiftgradient.c	1969-12-31 16:00:00.000000000 -0800
+++ b/sample/targets/c_model/vx_calcsiftgradient.c	2016-08-02 06:04:40.000000000 -0700
@@ -0,0 +1,487 @@
+/*
+ * Copyright (c) 2012-2014 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and/or associated documentation files (the
+ * "Materials"), to deal in the Materials without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Materials, and to
+ * permit persons to whom the Materials are furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Materials.
+ *
+ * THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
+ */
+
+
+#include <VX/vx.h>
+#include <VX/vxu.h>
+#include <VX/vx_helper.h>
+#include <VX/vx_lib_extras.h>
+#include <VX/vx_lib_debug.h>
+#include <vx_internal.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+
+static vx_status VX_CALLBACK vxCalcSiftGradientKernel(vx_node node, vx_reference *parameters, vx_uint32 num)
+{
+	if (num == 4)
+	{
+		//parameters
+		vx_image orien = (vx_image)parameters[0];
+		vx_image mag = (vx_image)parameters[1];
+		vx_array keypts = (vx_array)parameters[2];
+		vx_array descr = (vx_array)parameters[3];
+
+
+		//some important value. Because we're not handling radian or degree value.
+		//Rather we'll deal with 0~255 values which have been mapped from 0~6.28 radian values.
+
+
+		FILE* fff = NULL;
+		fff = fopen("www3.txt", "a+");
+
+
+
+		//neeeded kernels for small convolution.
+		//convolution matrix for entire window. sigma 1.5 (keypoint orientation)
+		vx_float32 window_convolution_mat[3][3] = { 
+			{ 0.095332, 0.118095, 0.095332 },
+			{0.118095, 0.146293, 0.118095},
+			{0.095332, 0.118095, 0.095332},
+
+		};
+
+
+
+		//convolution matrix for each patch (descriptor orientation)
+		vx_float32 patch_convolution_mat[3][3] = {
+			{ 0.110533, 0.111399, 0.110533 },
+			{ 0.111399, 0.112271, 0.111399 },
+			{ 0.110533, 0.111399, 0.110533 }
+
+		};
+
+		//access to keypoint array
+		vx_size num_keypts = 0;
+		vx_size stride = 0ul;
+		void* base = 0;
+		//vx_coordinates2d_t foundKey;
+		vx_int32 kpt_x, kpt_y;
+
+		vxQueryArray(keypts, VX_ARRAY_ATTRIBUTE_NUMITEMS, &num_keypts, sizeof(num_keypts));
+		vx_status st = vxAccessArrayRange(keypts, (vx_size)0, (vx_size)num_keypts, &stride, (void**)&base, VX_READ_ONLY);
+
+
+		fprintf(fff, "<%d>\n", num_keypts);
+
+		for (int kptidx = 0; kptidx < num_keypts; kptidx++)
+		{
+			
+			//retrieve a keypoint from array
+			vx_coordinates2d_t* xp = &vxArrayItem(vx_coordinates2d_t, base, kptidx, stride);
+			kpt_x = xp->x; kpt_y = xp->y;
+
+			//=================================================loop?
+
+			// @ ----- orientation of keypoint
+			vx_float32 keypoint_orient;
+
+			// @ ----- a window containing 16 bits around a keypoint
+			vx_float32 oriWin[16][16];		// - orientation values
+			vx_float32 magWin[16][16];		// - magnitude values
+
+			vx_float32 blurred_magWin[16][16];		// - blurred(convoluted) magnitude values for patches
+
+			vx_uint32 w, h;	//images' width&height. Assume size of two images(orientation/magnitude) are the same
+			vxQueryImage(orien, VX_IMAGE_ATTRIBUTE_WIDTH, &w, sizeof(w));
+			vxQueryImage(orien, VX_IMAGE_ATTRIBUTE_HEIGHT, &h, sizeof(h));
+
+			// @ ----- get 16 ORIENTATION pixels around keypoint to make 2d array
+			//patch for access gradient orientation image
+			vx_rectangle_t ori_imrect;
+			vx_uint32 ori_plane = 0;
+			vx_imagepatch_addressing_t ori_imaddr;
+			void* ori_imbaseptr = NULL;
+
+			//setting patch as entire size of image
+			ori_imrect.start_x = ori_imrect.start_y = 0;
+			ori_imrect.end_x = w; ori_imrect.end_y = h;
+
+			//access -> fill -> commit
+			vxAccessImagePatch(orien, &ori_imrect, ori_plane, &ori_imaddr, &ori_imbaseptr, VX_READ_ONLY);
+			for (int y = -7; y <= 8; y++)
+			{
+				for (int x = -7; x <= 8; x++)
+				{
+					vx_int16* currpixel = (vx_int16 *)vxFormatImagePatchAddress2d(ori_imbaseptr, kpt_x + x, kpt_y + y, &ori_imaddr);
+					oriWin[7 + y][7 + x] = (*currpixel);
+				}
+
+			}
+			vxCommitImagePatch(orien, &ori_imrect, ori_plane, &ori_imaddr, ori_imbaseptr);
+
+			// @ ----- get 16 MAGNITUDE pixels around keypoint to make 2d array
+			//patch for access gradient magnitude image
+			vx_rectangle_t mag_imrect;
+			vx_uint32 mag_plane = 0;
+			vx_imagepatch_addressing_t mag_imaddr;
+			void* mag_imbaseptr = NULL;
+
+			//setting patch as entire size of image
+			mag_imrect.start_x = mag_imrect.start_y = 0;
+			mag_imrect.end_x = w; mag_imrect.end_y = h;
+
+			//access -> fill -> commit
+			vxAccessImagePatch(mag, &mag_imrect, mag_plane, &mag_imaddr, &mag_imbaseptr, VX_READ_ONLY);
+			for (int y = -7; y <= 8; y++)
+			{
+				for (int x = -7; x <= 8; x++)
+				{
+					vx_int16* currpixel = (vx_int16 *)vxFormatImagePatchAddress2d(mag_imbaseptr, kpt_x + x, kpt_y + y, &mag_imaddr);
+					magWin[7+y][7+x] = (*currpixel);
+				}
+
+			}
+			vxCommitImagePatch(mag, &mag_imrect, mag_plane, &mag_imaddr, mag_imbaseptr);
+
+
+
+			// @ ----- do gaussian on magnitude values and fill histogram
+			vx_float32 histogram_36[36] = { 0, };
+
+			for (int i = 0; i < 16; i++)
+			{
+				for (int j = 0; j < 16; j++)
+				{
+					vx_float32 sum = 0;
+
+					for (int cr = -1; cr <= 1; cr++)
+					{
+						for (int cc = -1; cc <= 1; cc++)
+						{
+							//skip if we convolute nearby border
+							if ((i + cr >= 0 && i + cr <= 15) && (j + cc >= 0 && j + cc <= 15))
+								sum += magWin[i + cr][j + cc] * window_convolution_mat[1 + cr][1 + cc];
+						}
+					}
+
+					blurred_magWin[i][j] = sum;
+
+					//add to histogram array, indexing will be done with following i, j
+					histogram_36[((int)(oriWin[i][j])) / 10] += sum;
+
+				}
+			}
+
+
+			// @ ----- make HISTOGRAM from 16*16 window : 36 bins and pick dominant orientation of keypoint
+
+			//travel oriWin and check corresponding blurred_magWin
+			vx_float32 maxmag = 0.0f;
+			vx_int32 maxidx = 0;
+			for (int i = 0; i < 36; i++)
+			{
+				if (histogram_36[i] > maxmag)
+				{
+					maxmag = histogram_36[i];
+					maxidx = i;
+				}
+			}
+			//dominant orientation of keypoint
+			keypoint_orient = (vx_float32)(10 * maxidx);
+
+
+			// @ ----- do gaussian on orientation values
+			for (int i = 0; i < 16; i++)
+			{
+				for (int j = 0; j < 16; j++)
+				{
+					vx_float32 sum = 0;
+
+					for (int cr = -1; cr <= 1; cr++)
+					{
+						for (int cc = -1; cc <= 1; cc++)
+						{
+							//skip if we convolute nearby border
+							if ((i + cr >= 0 && i + cr <= 15) && (j + cc >= 0 && j + cc <= 15))
+								sum += magWin[i + cr][j + cc] * patch_convolution_mat[1 + cr][1 + cc];
+						}
+					}
+
+					//subtract keypoint orientation from blurred orientation for rotation invariance.
+					//if it became negative, add 360 for avoid having negative values.
+					if (sum - keypoint_orient < 0.0)
+						sum += 360.0;
+				
+					blurred_magWin[i][j] = sum;
+
+
+				}
+			}
+
+
+			// @ ----- assume 4*4 patches
+			vx_float32 descriptor_arr[128];
+			int descr_idx = 0;
+
+			// @ ----- make HISTOGRAM from 4*4 patches : 8 bins 
+			// @ ----- 8 values per patch -> 4*4*8 => 128 values per keypoint
+			for (int i = 0; i < 4; i++)
+			{
+				for (int j = 0; j < 4; j++)
+				{
+					vx_float32 patch_histogram[8];
+
+					for (int pi = 0; pi < 4; pi++)
+					{
+						for (int pj = 0; pj < 4; pj++)
+						{
+							patch_histogram[((int)blurred_magWin[i * 4 + pi][j * 4 + pj]) / 45] += blurred_magWin[i * 4 + pi][j * 4 + pj];
+						}
+					}
+
+					//[0] = 0~44		[1] = 45~89				[2] = 90~134
+					//[3] = 135~179		[4] = 180~224			[5] = 225~269
+					//[6] = 270~314		[7] = 315~359	
+
+					//concat patch_histogram (8 bytes) to descriptor_arr (128 bytes)
+					for (int di = 0; di < 8; di++)
+						descriptor_arr[descr_idx * 8 + di] = patch_histogram[di];
+
+					descr_idx += 8;
+
+				}
+			}
+			
+			// @ ----- add to array
+			for (int di = 0; di < 128; di++)
+			{
+				vxAddArrayItems(descr, 1, &descriptor_arr[di], 0);
+			}
+
+		}
+
+		vxCommitArrayRange(keypts, 0, num_keypts, base);
+
+
+		fclose(fff);
+
+		//FILE* fff = NULL;
+		//fff = fopen("www2.txt", "a+");
+
+		////magnitude threshold
+		//int MAGNITUDE_THRESHOLD = 300;
+
+		////for access to array
+		//vx_size i, j, stride = 0ul;
+		//void* base = 0;
+		//vx_coordinates2d_t foundKey;
+
+		////for access to magnitude image
+		//vx_rectangle_t imrect;
+		//vx_uint32 plane = 0;
+		//vx_imagepatch_addressing_t imaddr;
+		//void* imbaseptr = NULL;
+
+		////for writing to output vx image
+		//vx_rectangle_t output_imrect;
+		//vx_uint32 output_plane = 0;
+		//vx_imagepatch_addressing_t output_imaddr;
+		//void* output_imbaseptr = NULL;
+
+		////array data
+		//vx_size num_items;
+		//vx_status st;
+
+		//vx_uint32 w, h;	//images' width&height
+
+		////get width and height from image
+		//vxQueryImage(mag, VX_IMAGE_ATTRIBUTE_WIDTH, &w, sizeof(w));
+		//vxQueryImage(mag, VX_IMAGE_ATTRIBUTE_HEIGHT, &h, sizeof(h));
+
+		////get length of array and permission to access array
+		//vxQueryArray(before_arr, VX_ARRAY_ATTRIBUTE_NUMITEMS, &num_items, sizeof(num_items));
+		//st = vxAccessArrayRange(before_arr, (vx_size)0, (vx_size)num_items, &stride, (void**)&base, VX_READ_ONLY);
+		//if (st != VX_SUCCESS) fprintf(fff, "ACCESS ARAAY FAILED\n");
+
+		////setting patch as entire size of image and get permission to access image
+		//imrect.start_x = imrect.start_y = 0;
+		//imrect.end_x = w; imrect.end_y = h;
+		//st = vxAccessImagePatch(mag, &imrect, plane, &imaddr, &imbaseptr, VX_READ_ONLY);
+		//if (st != VX_SUCCESS) fprintf(fff, "ACCESS IMAGE FAILED [1]\n");
+
+		////setting patch for output vx_image for keypoint.
+		//output_imrect.start_x = output_imrect.start_y = 0;
+		//output_imrect.end_x = w; output_imrect.end_y = h;
+		//st = vxAccessImagePatch(output_image, &output_imrect, output_plane, &output_imaddr, &output_imbaseptr, VX_READ_AND_WRITE);
+		//if (st != VX_SUCCESS) fprintf(fff, "ACCESS IMAGE FAILED [2]\n");
+
+		//vx_int32 wwval, hhval;
+		//vxAccessScalarValue(img_width, &wwval);
+		//vxAccessScalarValue(img_height, &hhval);
+
+		////fprintf(fff, "w %d, h %d\n", wwval, hhval);
+		//
+		//for (i = 0; i < hhval; i++)
+		//{
+		//	for (j = 0; j < wwval; j++)
+		//	{
+		//		vx_uint8* outputpixel = (vx_uint8*)vxFormatImagePatchAddress2d(output_imbaseptr, j, i, &output_imaddr);
+		//		(*outputpixel) = (vx_uint8)0;
+		//	}
+		//}
+		//
+
+
+		//for (i = 0; i < num_items; i++)
+		//{
+		//	vx_coordinates2d_t* xp = &vxArrayItem(vx_coordinates2d_t, base, i, stride);
+
+		//	vx_int16* currpixel = (vx_int16 *)vxFormatImagePatchAddress2d(imbaseptr, xp->x, xp->y, &imaddr);
+		//	
+		//	if ((*currpixel) >= MAGNITUDE_THRESHOLD)
+		//	{
+		//		fprintf(fff, "%d %d\n", xp->x, xp->y);
+
+		//		//add to after verification array
+		//		foundKey.x = (vx_uint32)xp->x;
+		//		foundKey.y = (vx_uint32)xp->y;
+		//		vxAddArrayItems(after_arr, 1, &foundKey, 0);
+
+		//		vx_uint8* outputpixel = (vx_uint8*)vxFormatImagePatchAddress2d(output_imbaseptr, xp->x, xp->y, &output_imaddr);
+		//		(*outputpixel) = (vx_uint8)255;
+		//	}
+
+		//}
+		//vxCommitArrayRange(before_arr, 0, num_items, base);
+		//vxCommitImagePatch(mag, &imrect, plane, &imaddr, imbaseptr);
+		//vxCommitImagePatch(output_image, &output_imrect, output_plane, &output_imaddr, output_imbaseptr);
+
+		///////////////////////////////////
+		//FILE* fff2;
+		//fff2 = fopen("outim.pgm", "wb");
+
+		//fprintf(fff2, "P5\n%d %d\n255\n", wwval, hhval);
+		//for (i = 0; i < hhval; i++)
+		//{
+		//	for (j = 0; j < wwval; j++)
+		//	{
+		//		vx_uint8* outputpixel = (vx_uint8*)vxFormatImagePatchAddress2d(output_imbaseptr, j, i, &output_imaddr);
+		//		fprintf(fff2, "%c", (*outputpixel));
+		//	}
+		//}
+
+		//fclose(fff2);
+		///////////////////////////////////
+
+
+		//fclose(fff);
+
+
+		return VX_SUCCESS;
+    }
+    
+	return VX_ERROR_INVALID_PARAMETERS;
+}
+
+static vx_status VX_CALLBACK vxCalcSiftGradientInputValidator(vx_node node, vx_uint32 index)
+{
+	vx_status status = VX_ERROR_INVALID_PARAMETERS;
+	if (index == 0 || index == 1)
+	{
+		vx_image input = 0;
+		vx_parameter param = vxGetParameterByIndex(node, index);
+
+		vxQueryParameter(param, VX_PARAMETER_ATTRIBUTE_REF, &input, sizeof(input));
+		if (input)
+		{
+			vx_df_image format = 0;
+			vxQueryImage(input, VX_IMAGE_ATTRIBUTE_FORMAT, &format, sizeof(format));
+			if ((format == VX_DF_IMAGE_U8)
+				|| (format == VX_DF_IMAGE_S16)
+#if defined(EXPERIMENTAL_USE_S16)
+				|| (format == VX_DF_IMAGE_U16)
+				|| (format == VX_DF_IMAGE_U32)
+				|| (format == VX_DF_IMAGE_S32)
+#endif
+				)
+			{
+				status = VX_SUCCESS;
+			}
+			vxReleaseImage(&input);
+		}
+		vxReleaseParameter(&param);
+	}
+	
+	if (index == 2)
+	{
+		vx_parameter param = vxGetParameterByIndex(node, index);
+		if (param)
+		{
+			vx_array arr = 0;
+			vxQueryParameter(param, VX_PARAMETER_ATTRIBUTE_REF, &arr, sizeof(arr));
+			if (arr)
+			{
+				vx_enum item_type = 0;
+				vxQueryArray(arr, VX_ARRAY_ATTRIBUTE_ITEMTYPE, &item_type, sizeof(item_type));
+				if (item_type == VX_TYPE_COORDINATES2D)
+				{
+					status = VX_SUCCESS;
+				}
+				vxReleaseArray(&arr);
+			}
+			vxReleaseParameter(&param);
+		}
+	}
+
+	
+	return status;
+}
+
+static vx_status VX_CALLBACK vxCalcSiftGradientOutputValidator(vx_node node, vx_uint32 index, vx_meta_format_t *ptr)
+{
+
+    vx_status status = VX_ERROR_INVALID_PARAMETERS;
+	if (index == 3)
+	{
+		ptr->type = VX_TYPE_ARRAY;
+		ptr->dim.array.item_type = VX_TYPE_FLOAT32;
+		ptr->dim.array.capacity = 50000;
+		//no defined capacity requirement
+		status = VX_SUCCESS;
+	}
+    
+
+    return status;
+	
+}
+
+
+static vx_param_description_t calcsiftgradient_kernel_params[] = {
+	{ VX_INPUT, VX_TYPE_IMAGE, VX_PARAMETER_STATE_REQUIRED },
+	{ VX_INPUT, VX_TYPE_IMAGE, VX_PARAMETER_STATE_REQUIRED },
+	{ VX_INPUT, VX_TYPE_ARRAY, VX_PARAMETER_STATE_REQUIRED },
+	{ VX_OUTPUT, VX_TYPE_ARRAY, VX_PARAMETER_STATE_OPTIONAL },
+};
+
+vx_kernel_description_t calcsiftgradient_kernel = {
+	VX_KERNEL_CALCSIFTGRADIENT,
+	"org.khronos.openvx.nothing",
+	vxCalcSiftGradientKernel,
+	calcsiftgradient_kernel_params, dimof(calcsiftgradient_kernel_params),
+	vxCalcSiftGradientInputValidator,
+	vxCalcSiftGradientOutputValidator,
+	NULL,
+	NULL,
+};
+
diff -Npur -x '.*' a/sample/targets/c_model/vx_findsiftkeypoint.c b/sample/targets/c_model/vx_findsiftkeypoint.c
--- a/sample/targets/c_model/vx_findsiftkeypoint.c	1969-12-31 16:00:00.000000000 -0800
+++ b/sample/targets/c_model/vx_findsiftkeypoint.c	2016-08-08 17:06:51.000000000 -0700
@@ -0,0 +1,371 @@
+/*
+ * Copyright (c) 2012-2014 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and/or associated documentation files (the
+ * "Materials"), to deal in the Materials without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Materials, and to
+ * permit persons to whom the Materials are furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Materials.
+ *
+ * THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
+ */
+
+
+#include <VX/vx.h>
+#include <VX/vxu.h>
+#include <VX/vx_helper.h>
+#include <VX/vx_lib_extras.h>
+#include <VX/vx_lib_debug.h>
+#include <vx_internal.h>
+
+//#include <stdlib.h>
+//#include <stdio.h>
+
+static vx_status VX_CALLBACK vxFindSiftKeypointKernel(vx_node node, vx_reference *parameters, vx_uint32 num)
+{
+	if (num == 6)
+	{
+		//parameters
+		vx_image prev = (vx_image)parameters[0];
+		vx_image curr = (vx_image)parameters[1];
+		vx_image next = (vx_image)parameters[2];
+		vx_scalar octave = (vx_scalar)parameters[3];
+		vx_scalar maximum = (vx_scalar)parameters[4];
+		vx_array arr = (vx_array)parameters[5];
+
+		vx_coordinates2d_t foundKey;
+
+		//maximum keypoints can be detected for single call of this node amount to 1000
+		int keyptCnt = 0;
+
+		//constants from original openCV SIFT code
+		/*
+		vx_int32 SIFT_FIXPT_SCALE = 48;
+		vx_float32 img_scale = 1.f / (255 * SIFT_FIXPT_SCALE);
+		vx_float32 deriv_scale = img_scale*0.5f;				//img_scale * 0.5
+		vx_float32 second_deriv_scale = img_scale;				//img_scale
+		vx_float32 cross_deriv_scale = img_scale*0.25f;			//img_scale * 0.25
+
+		//solution of matrix equation <xi, xr, xc>
+		//we have to find out those values
+		vx_float32 xi = 0.0f;
+		vx_float32 xr = 0.0f;
+		vx_float32 xc = 0.0f;
+
+		//3d dD vector, right side of matrix equation.
+		vx_float32 dD[3] = { 0.0f, };
+
+		//3*3 Hessian Matrix, left side of matrix equation
+		vx_float33 Hess[3][3] = { .0f, };
+		*/
+
+		//patch for access vx_image curr
+		vx_rectangle_t curr_imrect;
+		vx_uint32 curr_plane = 0;
+		vx_imagepatch_addressing_t curr_imaddr;
+		void* curr_imbaseptr = NULL;
+		//patch for access vx_image prev
+		vx_rectangle_t prev_imrect;
+		vx_uint32 prev_plane = 0;
+		vx_imagepatch_addressing_t prev_imaddr;
+		void* prev_imbaseptr = NULL;
+		//patch for access vx_image next
+		vx_rectangle_t next_imrect;
+		vx_uint32 next_plane = 0;
+		vx_imagepatch_addressing_t next_imaddr;
+		void* next_imbaseptr = NULL;
+
+
+		//vx_reference DOG_pyramid_ref = (vx_reference)parameters[0];
+		//vx_image*  DOG_pyramid = (vx_image*)DOG_pyramid_ref;
+		//vx_array keypoints = (vx_array)parameters[1];
+
+		//FILE* fff = NULL;
+		//fff = fopen("www.txt", "a+");
+
+		//access to 'curr' vx_image
+		int SIFT_IMG_BORDER = 8;
+		//int VALUE_THRESHOLD = 50;
+		int r, c;
+		vx_int32 o;
+
+		//maximum keypoints
+		vx_int32 MAXIMUM_KEYPOINTS = 0;
+
+
+		//=================BEGIN. assume we're using same size of vx_images as paramters
+		vx_uint32 w, h;	//images' width&height
+		vxQueryImage(curr, VX_IMAGE_ATTRIBUTE_WIDTH, &w, sizeof(w));
+		vxQueryImage(curr, VX_IMAGE_ATTRIBUTE_HEIGHT, &h, sizeof(h));
+
+		//setting patch as entire size of image
+		curr_imrect.start_x = curr_imrect.start_y = 0;
+		curr_imrect.end_x = w; curr_imrect.end_y = h;
+		prev_imrect.start_x = prev_imrect.start_y = 0;
+		prev_imrect.end_x = w; prev_imrect.end_y = h;
+		next_imrect.start_x = next_imrect.start_y = 0;
+		next_imrect.end_x = w; next_imrect.end_y = h;
+
+		vxCopyScalar(octave, &o, VX_READ_ONLY, VX_MEMORY_TYPE_NONE);
+		vxCopyScalar(maximum, &MAXIMUM_KEYPOINTS, VX_READ_ONLY, VX_MEMORY_TYPE_NONE);
+
+		//fprintf(fff, "w : %d, h : %d\n, max : %d", w, h, (int)MAXIMUM_KEYPOINTS);
+
+		//allowing access to current vx_image layer
+		vxAccessImagePatch(curr, &curr_imrect, curr_plane, &curr_imaddr, &curr_imbaseptr, VX_READ_ONLY);
+		//allowing access to previous vx_image layer
+		vxAccessImagePatch(prev, &prev_imrect, prev_plane, &prev_imaddr, &prev_imbaseptr, VX_READ_ONLY);
+		//allowing access to next vx_image layer
+		vxAccessImagePatch(next, &next_imrect, next_plane, &next_imaddr, &next_imbaseptr, VX_READ_ONLY);
+
+		//fprintf(fff, "< ");
+
+		//pixel access loop
+		for (int y = SIFT_IMG_BORDER; y < (int)(h - SIFT_IMG_BORDER); y++)
+		{
+			for (int x = SIFT_IMG_BORDER; x < (int)(w - SIFT_IMG_BORDER); x++)
+			{
+
+				//currpixel : pixel we're looking as candidate. This one will be compared to neighboring..
+				vx_uint8* currpixel = (vx_uint8 *)vxFormatImagePatchAddress2d(curr_imbaseptr, x, y, &curr_imaddr);
+				//fprintf(fff, "%d ", (*currpixel));
+
+				//neighboring 8 pixels on same layer(vx_image curr)
+				vx_uint8* curr_neighbors[8] = {
+					(vx_uint8 *)vxFormatImagePatchAddress2d(curr_imbaseptr, x + 1, y, &curr_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(curr_imbaseptr, x + 1, y + 1, &curr_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(curr_imbaseptr, x, y + 1, &curr_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(curr_imbaseptr, x - 1, y + 1, &curr_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(curr_imbaseptr, x - 1, y, &curr_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(curr_imbaseptr, x - 1, y - 1, &curr_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(curr_imbaseptr, x, y - 1, &curr_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(curr_imbaseptr, x + 1, y - 1, &curr_imaddr)
+				};
+				//9 pixels on lower layer(previous layer)
+				vx_uint8 *prev_neighbors[9] = {
+					(vx_uint8 *)vxFormatImagePatchAddress2d(prev_imbaseptr, x, y, &prev_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(prev_imbaseptr, x + 1, y, &prev_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(prev_imbaseptr, x + 1, y + 1, &prev_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(prev_imbaseptr, x, y + 1, &prev_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(prev_imbaseptr, x - 1, y + 1, &prev_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(prev_imbaseptr, x - 1, y, &prev_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(prev_imbaseptr, x - 1, y - 1, &prev_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(prev_imbaseptr, x, y - 1, &prev_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(prev_imbaseptr, x + 1, y - 1, &prev_imaddr)
+				};
+				//9 pixels on upper layer(next layer)
+				vx_uint8 *next_neighbors[9] = {
+					(vx_uint8 *)vxFormatImagePatchAddress2d(next_imbaseptr, x, y, &next_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(next_imbaseptr, x + 1, y, &next_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(next_imbaseptr, x + 1, y + 1, &next_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(next_imbaseptr, x, y + 1, &next_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(next_imbaseptr, x - 1, y + 1, &next_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(next_imbaseptr, x - 1, y, &next_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(next_imbaseptr, x - 1, y - 1, &next_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(next_imbaseptr, x, y - 1, &next_imaddr),
+					(vx_uint8 *)vxFormatImagePatchAddress2d(next_imbaseptr, x + 1, y - 1, &next_imaddr)
+				};
+
+
+				if (
+					((*currpixel) >= (*curr_neighbors[0])) && ((*currpixel) >= (*curr_neighbors[1])) && ((*currpixel) >= (*curr_neighbors[2])) && ((*currpixel) >= (*curr_neighbors[3]))
+					&& ((*currpixel) >= (*curr_neighbors[4])) && ((*currpixel) >= (*curr_neighbors[5])) && ((*currpixel) >= (*curr_neighbors[6])) && ((*currpixel) >= (*curr_neighbors[7]))
+					&& ((*currpixel) >= (*prev_neighbors[0])) && ((*currpixel) >= (*prev_neighbors[1])) && ((*currpixel) >= (*prev_neighbors[2])) && ((*currpixel) >= (*prev_neighbors[3]))
+					&& ((*currpixel) >= (*prev_neighbors[4])) && ((*currpixel) >= (*prev_neighbors[5])) && ((*currpixel) >= (*prev_neighbors[6])) && ((*currpixel) >= (*prev_neighbors[7]))
+					&& ((*currpixel) >= (*prev_neighbors[8])) && ((*currpixel) >= (*next_neighbors[0])) && ((*currpixel) >= (*next_neighbors[1])) && ((*currpixel) >= (*next_neighbors[2]))
+					&& ((*currpixel) >= (*next_neighbors[3])) && ((*currpixel) >= (*next_neighbors[4])) && ((*currpixel) >= (*next_neighbors[5])) && ((*currpixel) >= (*next_neighbors[6]))
+					&& ((*currpixel) >= (*next_neighbors[7])) && ((*currpixel) >= (*next_neighbors[8]))
+					)
+				{
+					//if we found maxima/minima, save the position
+
+
+					//and next, check if the corresponding pixel is in edge or not
+					vx_int16 d = *currpixel;
+					vx_float32 dxx = (*curr_neighbors[2]) + (*curr_neighbors[6]) - 2 * d;
+					vx_float32 dyy = (*curr_neighbors[0]) + (*curr_neighbors[4]) - 2 * d;
+					vx_float32 dxy = ((*curr_neighbors[1]) - (*curr_neighbors[3]) - (*curr_neighbors[5]) - (*curr_neighbors[7])) / 4.0;
+
+					vx_float32 tr = dxx + dyy;
+					vx_float32 det = dxx * dyy - dxy * dxy;
+
+					//is edge?
+					if (det > 0 && tr * tr / det < (10 + 1.0)*(10 + 1.0) / 10)
+					{
+
+						r = y; c = x;
+						r = r*(1 << o);
+						c = c*(1 << o);
+						foundKey.x = (vx_uint32)c;
+						foundKey.y = (vx_uint32)r;
+						vxAddArrayItems(arr, 1, &foundKey, 0);
+
+						//fprintf(fff, "[%d %d]\n", c, r);
+
+						keyptCnt++;
+					}
+
+					//fprintf(fff, "%c", (*ptr2));
+
+					if (keyptCnt >= ((int)MAXIMUM_KEYPOINTS)) break;
+				}
+
+				if (keyptCnt >= ((int)MAXIMUM_KEYPOINTS)) break;
+			}
+
+		}
+
+		//fprintf(fff, ">");
+
+		//commit current layer
+		vxCommitImagePatch(curr, &curr_imrect, curr_plane, &curr_imaddr, curr_imbaseptr);
+		//commit previous layer
+		vxCommitImagePatch(prev, &prev_imrect, prev_plane, &prev_imaddr, prev_imbaseptr);
+		//commit next layer
+		vxCommitImagePatch(next, &next_imrect, next_plane, &next_imaddr, next_imbaseptr);
+
+		//vxAccessScalarValue(octave, &o);
+		//fprintf(fff, "received %d as octave\n", o);
+
+		//fclose(fff);
+		//=================END
+
+
+
+		/*
+		a1.x = (vx_uint32)111;
+		a1.y = (vx_uint32)333;
+		a2.x = (vx_uint32)2222;
+		a2.y = (vx_uint32)4444;
+		a3.x = (vx_uint32)o;
+		a3.y = (vx_uint32)o;
+
+		vxAddArrayItems(arr, 1, &a1, 0);
+		vxAddArrayItems(arr, 1, &a2, 0);
+		vxAddArrayItems(arr, 1, &a3, 0);
+		*/
+
+
+		return VX_SUCCESS;
+	}
+
+	return VX_ERROR_INVALID_PARAMETERS;
+}
+
+static vx_status VX_CALLBACK vxFindSiftKeypointInputValidator(vx_node node, vx_uint32 index)
+{
+	vx_status status = VX_ERROR_INVALID_PARAMETERS;
+	if (index == 0 | index == 1 | index == 2)
+	{
+		vx_image input = 0;
+		vx_parameter param = vxGetParameterByIndex(node, index);
+
+		vxQueryParameter(param, VX_PARAMETER_ATTRIBUTE_REF, &input, sizeof(input));
+		if (input)
+		{
+			vx_df_image format = 0;
+			vxQueryImage(input, VX_IMAGE_ATTRIBUTE_FORMAT, &format, sizeof(format));
+			if ((format == VX_DF_IMAGE_U8)
+				|| (format == VX_DF_IMAGE_S16)
+#if defined(EXPERIMENTAL_USE_S16)
+				|| (format == VX_DF_IMAGE_U16)
+				|| (format == VX_DF_IMAGE_U32)
+				|| (format == VX_DF_IMAGE_S32)
+#endif
+				)
+			{
+				status = VX_SUCCESS;
+			}
+			vxReleaseImage(&input);
+		}
+		vxReleaseParameter(&param);
+	}
+	if (index == 3 || index == 4)
+	{
+
+		vx_parameter param = vxGetParameterByIndex(node, index);
+		vx_scalar scalar = 0;
+		status = vxQueryParameter(param, VX_PARAMETER_ATTRIBUTE_REF, &scalar, sizeof(scalar));
+
+
+		vx_enum type = 0;
+		vxQueryScalar(scalar, VX_SCALAR_ATTRIBUTE_TYPE, &type, sizeof(type));
+		if (type == VX_TYPE_INT32)
+		{
+			vx_int32 o = 0;
+			vxCopyScalar(scalar, &o, VX_READ_ONLY, VX_MEMORY_TYPE_NONE);
+			if (o >= 0)
+			{
+				status = VX_SUCCESS;
+			}
+			else
+			{
+				status = VX_ERROR_INVALID_VALUE;
+			}
+		}
+	}
+	return status;
+}
+
+static vx_status VX_CALLBACK vxFindSiftKeypointOutputValidator(vx_node node, vx_uint32 index, vx_meta_format_t *ptr)
+{
+
+	vx_status status = VX_ERROR_INVALID_PARAMETERS;
+	if (index == 5)
+	{
+		vx_parameter param = vxGetParameterByIndex(node, 4);
+
+		if (param)
+		{
+			vx_scalar maximum;
+			vx_int32 max_keypoint_num;
+			vxQueryParameter(param, VX_PARAMETER_ATTRIBUTE_REF, &maximum, sizeof(maximum));
+
+			vxCopyScalar(maximum, &max_keypoint_num, VX_READ_ONLY, VX_MEMORY_TYPE_NONE);
+
+			ptr->type = VX_TYPE_ARRAY;
+			ptr->dim.array.item_type = VX_TYPE_COORDINATES2D;
+			ptr->dim.array.capacity = max_keypoint_num;
+			//no defined capacity requirement
+			status = VX_SUCCESS;
+			vxReleaseScalar(&maximum);
+
+		}
+		vxReleaseParameter(&param);
+	}
+
+	return status;
+
+}
+
+
+static vx_param_description_t findsiftkeypoint_kernel_params[] = {
+	{ VX_INPUT, VX_TYPE_IMAGE, VX_PARAMETER_STATE_REQUIRED },
+	{ VX_INPUT, VX_TYPE_IMAGE, VX_PARAMETER_STATE_REQUIRED },
+	{ VX_INPUT, VX_TYPE_IMAGE, VX_PARAMETER_STATE_REQUIRED },
+	{ VX_INPUT, VX_TYPE_SCALAR, VX_PARAMETER_STATE_REQUIRED },
+	{ VX_INPUT, VX_TYPE_SCALAR, VX_PARAMETER_STATE_REQUIRED },
+	{ VX_OUTPUT, VX_TYPE_ARRAY, VX_PARAMETER_STATE_OPTIONAL },
+};
+
+vx_kernel_description_t findsiftkeypoint_kernel = {
+	VX_KERNEL_FINDSIFTKEYPOINT,
+	"org.khronos.openvx.nothing",
+	vxFindSiftKeypointKernel,
+	findsiftkeypoint_kernel_params, dimof(findsiftkeypoint_kernel_params),
+	vxFindSiftKeypointInputValidator,
+	vxFindSiftKeypointOutputValidator,
+	NULL,
+	NULL,
+};
diff -Npur -x '.*' a/sample/targets/c_model/vx_interface.c b/sample/targets/c_model/vx_interface.c
--- a/sample/targets/c_model/vx_interface.c	2016-06-17 10:02:31.000000000 -0700
+++ b/sample/targets/c_model/vx_interface.c	2016-08-08 16:31:24.000000000 -0700
@@ -1,4 +1,4 @@
-/* 
+/*
  * Copyright (c) 2012-2016 The Khronos Group Inc.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
@@ -94,6 +94,9 @@ static vx_kernel_description_t *target_k
     &laplacian_pyramid_kernel,
     &laplacian_reconstruct_kernel,
     &nonlinearfilter_kernel,
+    &findsiftkeypoint_kernel,
+    &verifykeypoint_kernel,
+    &calcsiftgradient_kernel,
 };
 
 /*! \brief Declares the number of base supported kernels.
@@ -530,4 +533,3 @@ vx_status VX_CALLBACK vxTilingKernel(vx_
     return status;
 }
 #endif
-
diff -Npur -x '.*' a/sample/targets/c_model/vx_interface.h b/sample/targets/c_model/vx_interface.h
--- a/sample/targets/c_model/vx_interface.h	2016-06-17 10:02:31.000000000 -0700
+++ b/sample/targets/c_model/vx_interface.h	2016-08-08 16:32:44.000000000 -0700
@@ -1,4 +1,4 @@
-/* 
+/*
  * Copyright (c) 2012-2016 The Khronos Group Inc.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
@@ -79,6 +79,8 @@ extern vx_kernel_description_t halfscale
 extern vx_kernel_description_t laplacian_pyramid_kernel;
 extern vx_kernel_description_t laplacian_reconstruct_kernel;
 extern vx_kernel_description_t nonlinearfilter_kernel;
+extern vx_kernel_description_t findsiftkeypoint_kernel;
+extern vx_kernel_description_t verifykeypoint_kernel;
+extern vx_kernel_description_t calcsiftgradient_kernel;
 
 #endif
-
diff -Npur -x '.*' a/sample/targets/c_model/vx_verifykeypoint.c b/sample/targets/c_model/vx_verifykeypoint.c
--- a/sample/targets/c_model/vx_verifykeypoint.c	1969-12-31 16:00:00.000000000 -0800
+++ b/sample/targets/c_model/vx_verifykeypoint.c	2016-08-08 17:02:33.000000000 -0700
@@ -0,0 +1,359 @@
+/*
+ * Copyright (c) 2012-2014 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and/or associated documentation files (the
+ * "Materials"), to deal in the Materials without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Materials, and to
+ * permit persons to whom the Materials are furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Materials.
+ *
+ * THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
+ */
+
+
+#include <VX/vx.h>
+#include <VX/vxu.h>
+#include <VX/vx_helper.h>
+#include <VX/vx_lib_extras.h>
+#include <VX/vx_lib_debug.h>
+#include <vx_internal.h>
+
+//#include <stdlib.h>
+//#include <stdio.h>
+
+static vx_status VX_CALLBACK vxVerifyKeypointKernel(vx_node node, vx_reference *parameters, vx_uint32 num)
+{
+    if (num == 7)
+    {
+		//parameters
+		vx_array before_arr = (vx_array)parameters[0];
+		vx_image mag = (vx_image)parameters[1];
+		vx_scalar img_width = (vx_scalar)parameters[2];
+		vx_scalar img_height = (vx_scalar)parameters[3];
+		vx_scalar maximum = (vx_scalar)parameters[4];
+		vx_array after_arr = (vx_array)parameters[5];
+		vx_image output_image = (vx_image)parameters[6];
+
+
+		//maximum keypoints can be detected for single call of this node amount to 200
+		int keyptCnt = 0;
+
+		//FILE* fff = NULL;
+		//fff = fopen("www2.txt", "a+");
+
+		//magnitude threshold
+		int MAGNITUDE_THRESHOLD = 70;
+
+		//maximum keypoints
+		vx_int32 MAXIMUM_KEYPOINTS = 0;
+
+		//for access to array
+		vx_size i, j, stride = 0ul;
+		void* base = 0;
+		vx_coordinates2d_t foundKey;
+
+		//for access to magnitude image
+		vx_rectangle_t imrect;
+		vx_uint32 plane = 0;
+		vx_imagepatch_addressing_t imaddr;
+		void* imbaseptr = NULL;
+
+		//for writing to output vx image
+		vx_rectangle_t output_imrect;
+		vx_uint32 output_plane = 0;
+		vx_imagepatch_addressing_t output_imaddr;
+		void* output_imbaseptr = NULL;
+
+		//array data
+		vx_size num_items;
+		vx_status st;
+
+		vx_uint32 w, h;	//images' width&height
+
+		//get width and height from image
+		vxQueryImage(mag, VX_IMAGE_ATTRIBUTE_WIDTH, &w, sizeof(w));
+		vxQueryImage(mag, VX_IMAGE_ATTRIBUTE_HEIGHT, &h, sizeof(h));
+
+		//get length of array and permission to access array
+		vxQueryArray(before_arr, VX_ARRAY_ATTRIBUTE_NUMITEMS, &num_items, sizeof(num_items));
+
+		st = vxAccessArrayRange(before_arr, (vx_size)0, (vx_size)num_items, &stride, (void**)&base, VX_READ_ONLY);
+		if (st != VX_SUCCESS) return VX_SUCCESS;
+
+		//setting patch as entire size of image and get permission to access image
+		imrect.start_x = imrect.start_y = 0;
+		imrect.end_x = w; imrect.end_y = h;
+		st = vxAccessImagePatch(mag, &imrect, plane, &imaddr, &imbaseptr, VX_READ_ONLY);
+		//if (st != VX_SUCCESS) fprintf(fff, "ACCESS IMAGE FAILED [1]\n");
+
+		//setting patch for output vx_image for keypoint.
+		output_imrect.start_x = output_imrect.start_y = 0;
+		output_imrect.end_x = w; output_imrect.end_y = h;
+		st = vxAccessImagePatch(output_image, &output_imrect, output_plane, &output_imaddr, &output_imbaseptr, VX_READ_AND_WRITE);
+		//if (st != VX_SUCCESS) fprintf(fff, "ACCESS IMAGE FAILED [2]\n");
+
+		vx_int32 wwval, hhval;
+
+		vxCopyScalar(img_width, &wwval, VX_READ_ONLY, VX_MEMORY_TYPE_NONE);
+		vxCopyScalar(img_height, &hhval, VX_READ_ONLY, VX_MEMORY_TYPE_NONE);
+
+		vxCopyScalar(maximum, &MAXIMUM_KEYPOINTS, VX_READ_ONLY, VX_MEMORY_TYPE_NONE );
+
+		//fprintf(fff, "w %d, h %d, max %d\n", wwval, hhval, (int)MAXIMUM_KEYPOINTS);
+
+		//writing keypoint to image
+		/*
+		for (i = 0; i < hhval; i++)
+		{
+			for (j = 0; j < wwval; j++)
+			{
+				vx_uint8* outputpixel = (vx_uint8*)vxFormatImagePatchAddress2d(output_imbaseptr, j, i, &output_imaddr);
+				(*outputpixel) = (vx_uint8)0;
+			}
+		}
+		*/
+
+
+
+		for (i = 0; i < num_items; i++)
+		{
+			vx_coordinates2d_t* xp = &vxArrayItem(vx_coordinates2d_t, base, i, stride);
+
+			vx_int16* currpixel = (vx_int16 *)vxFormatImagePatchAddress2d(imbaseptr, xp->x, xp->y, &imaddr);
+
+			if ((*currpixel) >= MAGNITUDE_THRESHOLD)
+			{
+
+
+
+				//fprintf(fff, "%d %d\n", xp->x, xp->y);
+
+				//add to after verification array
+				foundKey.x = (vx_uint32)xp->x;
+				foundKey.y = (vx_uint32)xp->y;
+				vxAddArrayItems(after_arr, 1, &foundKey, 0);
+
+				vx_uint8* outputpixel = (vx_uint8*)vxFormatImagePatchAddress2d(output_imbaseptr, xp->x, xp->y, &output_imaddr);
+				(*outputpixel) = (vx_uint8)255;
+
+				keyptCnt++;
+
+				if (keyptCnt >= ((int)MAXIMUM_KEYPOINTS)) break;
+			}
+
+			if (keyptCnt >= ((int)MAXIMUM_KEYPOINTS)) break;
+		}
+		vxCommitArrayRange(before_arr, 0, num_items, base);
+		vxCommitImagePatch(mag, &imrect, plane, &imaddr, imbaseptr);
+		vxCommitImagePatch(output_image, &output_imrect, output_plane, &output_imaddr, output_imbaseptr);
+
+		/////////////////////////////////
+		//writing keypoint to image
+		/*
+		FILE* fff2;
+		fff2 = fopen("outim.pgm", "wb");
+
+		fprintf(fff2, "P5\n%d %d\n255\n", wwval, hhval);
+		for (i = 0; i < hhval; i++)
+		{
+			for (j = 0; j < wwval; j++)
+			{
+				vx_uint8* outputpixel = (vx_uint8*)vxFormatImagePatchAddress2d(output_imbaseptr, j, i, &output_imaddr);
+				fprintf(fff2, "%c", (*outputpixel));
+			}
+		}
+
+		fclose(fff2);
+		/////////////////////////////////
+
+
+		fclose(fff);
+		*/
+
+		//fclose(fff);
+
+		return VX_SUCCESS;
+    }
+
+	return VX_ERROR_INVALID_PARAMETERS;
+}
+
+static vx_status VX_CALLBACK vxVerifyKeypointInputValidator(vx_node node, vx_uint32 index)
+{
+	vx_status status = VX_ERROR_INVALID_PARAMETERS;
+	if (index == 1)
+	{
+		vx_image input = 0;
+		vx_parameter param = vxGetParameterByIndex(node, index);
+
+		vxQueryParameter(param, VX_PARAMETER_ATTRIBUTE_REF, &input, sizeof(input));
+		if (input)
+		{
+			vx_df_image format = 0;
+			vxQueryImage(input, VX_IMAGE_ATTRIBUTE_FORMAT, &format, sizeof(format));
+			if ((format == VX_DF_IMAGE_U8)
+				|| (format == VX_DF_IMAGE_S16)
+#if defined(EXPERIMENTAL_USE_S16)
+				|| (format == VX_DF_IMAGE_U16)
+				|| (format == VX_DF_IMAGE_U32)
+				|| (format == VX_DF_IMAGE_S32)
+#endif
+				)
+			{
+				status = VX_SUCCESS;
+			}
+			vxReleaseImage(&input);
+		}
+		vxReleaseParameter(&param);
+	}
+
+	if (index == 0)
+	{
+		vx_parameter param = vxGetParameterByIndex(node, index);
+		if (param)
+		{
+			vx_array arr = 0;
+			vxQueryParameter(param, VX_PARAMETER_ATTRIBUTE_REF, &arr, sizeof(arr));
+			if (arr)
+			{
+				vx_enum item_type = 0;
+				vxQueryArray(arr, VX_ARRAY_ATTRIBUTE_ITEMTYPE, &item_type, sizeof(item_type));
+				if (item_type == VX_TYPE_COORDINATES2D)
+				{
+					status = VX_SUCCESS;
+				}
+				vxReleaseArray(&arr);
+			}
+			vxReleaseParameter(&param);
+		}
+	}
+
+	if (index == 4 || index == 3 || index == 2)
+	{
+
+		vx_parameter param = vxGetParameterByIndex(node, index);
+		vx_scalar scalar = 0;
+		status = vxQueryParameter(param, VX_PARAMETER_ATTRIBUTE_REF, &scalar, sizeof(scalar));
+
+
+		vx_enum type = 0;
+		vxQueryScalar(scalar, VX_SCALAR_ATTRIBUTE_TYPE, &type, sizeof(type));
+		if (type == VX_TYPE_INT32)
+		{
+			vx_int32 o = 0;
+      vxCopyScalar(scalar, &o, VX_READ_ONLY, VX_MEMORY_TYPE_NONE);
+			if (o >= 0)
+			{
+				status = VX_SUCCESS;
+			}
+			else
+			{
+				status = VX_ERROR_INVALID_VALUE;
+			}
+		}
+	}
+
+	return status;
+}
+
+static vx_status VX_CALLBACK vxVerifyKeypointOutputValidator(vx_node node, vx_uint32 index, vx_meta_format_t *ptr)
+{
+
+    vx_status status = VX_ERROR_INVALID_PARAMETERS;
+	if (index == 5)
+	{
+		vx_parameter param = vxGetParameterByIndex(node, 4);
+
+		if (param)
+		{
+			vx_scalar maximum;
+			vx_int32 max_keypoint_num;
+			vxQueryParameter(param, VX_PARAMETER_ATTRIBUTE_REF, &maximum, sizeof(maximum));
+
+			vxCopyScalar(maximum, &max_keypoint_num, VX_READ_ONLY, VX_MEMORY_TYPE_NONE);
+
+			ptr->type = VX_TYPE_ARRAY;
+			ptr->dim.array.item_type = VX_TYPE_COORDINATES2D;
+			ptr->dim.array.capacity = max_keypoint_num;
+			//no defined capacity requirement
+			status = VX_SUCCESS;
+
+			vxReleaseScalar(&maximum);
+
+		}
+		vxReleaseParameter(&param);
+
+
+	}
+	if (index == 6)
+    {
+
+		vx_parameter param[2] = {
+			vxGetParameterByIndex(node, 2),
+			vxGetParameterByIndex(node, 3),
+		};
+
+		if (param[0] && param[1])
+		{
+			vx_int32 img_w;
+			vx_int32 img_h;
+			vx_scalar w_scalar;
+			vx_scalar h_scalar;
+			vxQueryParameter(param[0], VX_PARAMETER_ATTRIBUTE_REF, &w_scalar, sizeof(w_scalar));
+			vxQueryParameter(param[1], VX_PARAMETER_ATTRIBUTE_REF, &h_scalar, sizeof(h_scalar));
+
+      vxCopyScalar(w_scalar, &img_w, VX_READ_ONLY, VX_MEMORY_TYPE_NONE);
+      vxCopyScalar(h_scalar, &img_h, VX_READ_ONLY, VX_MEMORY_TYPE_NONE);
+
+
+			ptr->type = VX_TYPE_IMAGE;
+			ptr->dim.image.format = VX_DF_IMAGE_U8;
+			ptr->dim.image.width = img_w;
+			ptr->dim.image.height = img_h;
+			status = VX_SUCCESS;
+
+
+			vxReleaseScalar(&w_scalar);
+			vxReleaseScalar(&h_scalar);
+		}
+
+		vxReleaseParameter(&param[0]);
+		vxReleaseParameter(&param[1]);
+    }
+
+    return status;
+
+}
+
+
+static vx_param_description_t verifykeypoint_kernel_params[] = {
+	{ VX_INPUT, VX_TYPE_ARRAY, VX_PARAMETER_STATE_REQUIRED },
+	{ VX_INPUT, VX_TYPE_IMAGE, VX_PARAMETER_STATE_REQUIRED },
+	{ VX_INPUT, VX_TYPE_SCALAR, VX_PARAMETER_STATE_REQUIRED },
+	{ VX_INPUT, VX_TYPE_SCALAR, VX_PARAMETER_STATE_REQUIRED },
+	{ VX_INPUT, VX_TYPE_SCALAR, VX_PARAMETER_STATE_REQUIRED },
+	{ VX_OUTPUT, VX_TYPE_ARRAY, VX_PARAMETER_STATE_OPTIONAL },
+	{VX_OUTPUT, VX_TYPE_IMAGE, VX_PARAMETER_STATE_OPTIONAL },
+};
+
+vx_kernel_description_t verifykeypoint_kernel = {
+	VX_KERNEL_VERIFYKEYPOINT,
+	"org.khronos.openvx.nothing",
+	vxVerifyKeypointKernel,
+	verifykeypoint_kernel_params, dimof(verifykeypoint_kernel_params),
+	vxVerifyKeypointInputValidator,
+	vxVerifyKeypointOutputValidator,
+	NULL,
+	NULL,
+};
diff -Npur -x '.*' a/sample/targets/opencl/vx_interface.h b/sample/targets/opencl/vx_interface.h
--- a/sample/targets/opencl/vx_interface.h	2016-06-17 10:02:31.000000000 -0700
+++ b/sample/targets/opencl/vx_interface.h	2016-08-07 20:46:45.000000000 -0700
@@ -1,4 +1,4 @@
-/* 
+/*
  * Copyright (c) 2012-2016 The Khronos Group Inc.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
@@ -37,7 +37,7 @@
 
 #include <vx_internal.h>
 
-#if defined(DARWIN)
+#if defined(DARWIN) || defined(__APPLE__)
 #include <OpenCL/opencl.h>
 #else
 #include <CL/cl.h>
@@ -112,5 +112,3 @@ extern vx_cl_kernel_description_t not_ke
 extern vx_cl_kernel_description_t histogram_kernel;
 
 #endif
-
-
diff -Npur -x '.*' a/sample/vxu/CMakeLists.txt b/sample/vxu/CMakeLists.txt
--- a/sample/vxu/CMakeLists.txt	2016-06-17 10:02:32.000000000 -0700
+++ b/sample/vxu/CMakeLists.txt	2016-08-07 20:47:49.000000000 -0700
@@ -35,11 +35,11 @@ include_directories( BEFORE
                      ${CMAKE_CURRENT_SOURCE_DIR}/../include
                      ${CMAKE_SOURCE_DIR}/debug
                      ${CMAKE_SOURCE_DIR}/include )
-					 
+
 if ((WIN32) OR (CYGWIN))
    add_definitions( ${OPENVX_BUILDING_EXPORT_DEF} )
 endif ((WIN32) OR (CYGWIN))
-					 
+
 FIND_SOURCES()
 
 if ((WIN32) OR (CYGWIN))
@@ -55,9 +55,9 @@ endif (CYGWIN)
 
 target_link_libraries( ${TARGET_NAME} openvx openvx-helper )
 
-install ( TARGETS ${TARGET_NAME} 
+install ( TARGETS ${TARGET_NAME}
           RUNTIME DESTINATION bin
           ARCHIVE DESTINATION lib
-          LIBRARY DESTINATION bin )
-		  
-set_target_properties( ${TARGET_NAME} PROPERTIES FOLDER ${SAMPLE_FOLDER} )
\ No newline at end of file
+          LIBRARY DESTINATION lib )
+
+set_target_properties( ${TARGET_NAME} PROPERTIES FOLDER ${SAMPLE_FOLDER} )
diff -Npur -x '.*' a/sample/vxu/vx_utility.c b/sample/vxu/vx_utility.c
--- a/sample/vxu/vx_utility.c	2016-06-17 10:02:32.000000000 -0700
+++ b/sample/vxu/vx_utility.c	2016-08-08 16:52:06.000000000 -0700
@@ -1,4 +1,4 @@
-/* 
+/*
  * Copyright (c) 2012-2016 The Khronos Group Inc.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
@@ -1185,6 +1185,71 @@ VX_API_ENTRY vx_status VX_API_CALL vxuRe
             {
                 status = vxProcessGraph(graph);
             }
+            vxReleaseNode(&node);
+        }
+        vxReleaseGraph(&graph);
+    }
+    return status;
+}
+
+VX_API_ENTRY vx_status VX_API_CALL vxuFindSiftKeypoint(vx_context context, vx_image prev, vx_image curr, vx_image next, vx_int32 octave, vx_int32 maximum, vx_array arr)
+{
+    vx_status status = VX_FAILURE;
+    vx_graph graph = vxCreateGraph(context);
+    if (graph)
+    {
+		    vx_node node = vxFindSiftKeypointNode(graph, prev, curr, next, octave, maximum, arr);
+		    if (node)
+		    {
+			      status = vxVerifyGraph(graph);
+			      if (status == VX_SUCCESS)
+			      {
+				        status = vxProcessGraph(graph);
+			      }
+			      vxReleaseNode(&node);
+		    }
+		    vxReleaseGraph(&graph);
+	  }
+    return status;
+}
+
+
+VX_API_ENTRY vx_status VX_API_CALL vxuVerifyKeypoint(vx_context context, vx_array before, vx_image mag, vx_int32 w, vx_int32 h, vx_int32 maximum, vx_array after, vx_image keyptimg)
+{
+    vx_status status = VX_FAILURE;
+    vx_graph graph = vxCreateGraph(context);
+    if (graph)
+    {
+		    vx_node node = vxVerifyKeypointNode(graph, before, mag, w, h, maximum, after, keyptimg);
+		    if (node)
+        {
+            status = vxVerifyGraph(graph);
+            if (status == VX_SUCCESS)
+            {
+				        status = vxProcessGraph(graph);
+            }
+			      vxReleaseNode(&node);
+		     }
+		     vxReleaseGraph(&graph);
+    }
+    return status;
+}
+
+
+VX_API_ENTRY vx_status VX_API_CALL vxuCalcSiftGradient(vx_context context, vx_image orient, vx_image magni, vx_array keypt, vx_array descr)
+{
+    vx_status status = VX_FAILURE;
+    vx_graph graph = vxCreateGraph(context);
+    if (graph)
+    {
+        vx_node node = vxCalcSiftGradientNode(graph, orient, magni, keypt, descr);
+        if (node)
+        {
+            status = vxVerifyGraph(graph);
+			      if (status == VX_SUCCESS)
+            {
+                status = vxProcessGraph(graph);
+            }
             vxReleaseNode(&node);
         }
         vxReleaseGraph(&graph);
